--- patch-3.7.5.patch	2013-02-04 05:19:56.872741710 +0200
+++ patch-3.7.6.patch	2013-02-06 08:44:21.365468877 +0200
@@ -1,3 +1,12 @@
+diff --git a/Documentation/device-mapper/dm-raid.txt b/Documentation/device-mapper/dm-raid.txt
+index 728c38c..56fb62b 100644
+--- a/Documentation/device-mapper/dm-raid.txt
++++ b/Documentation/device-mapper/dm-raid.txt
+@@ -141,3 +141,4 @@ Version History
+ 1.2.0	Handle creation of arrays that contain failed devices.
+ 1.3.0	Added support for RAID 10
+ 1.3.1	Allow device replacement/rebuild for RAID 10
++1.3.2   Fix/improve redundancy checking for RAID10
 diff --git a/Documentation/power/runtime_pm.txt b/Documentation/power/runtime_pm.txt
 index 4abe83e..03591a7 100644
 --- a/Documentation/power/runtime_pm.txt
@@ -21,14 +30,14 @@
  7. Generic subsystem callbacks
  
 diff --git a/Makefile b/Makefile
-index 540f7b2..ecf87b1 100644
+index 540f7b2..b6de2ea 100644
 --- a/Makefile
 +++ b/Makefile
 @@ -1,6 +1,6 @@
  VERSION = 3
  PATCHLEVEL = 7
 -SUBLEVEL = 0
-+SUBLEVEL = 5
++SUBLEVEL = 6
  EXTRAVERSION =
  NAME = Terrified Chipmunk
  
@@ -66,6 +75,93 @@
  	$(call cmd,rmdirs)
  	$(call cmd,rmfiles)
  	@find $(if $(KBUILD_EXTMOD), $(KBUILD_EXTMOD), .) $(RCS_FIND_IGNORE) \
+diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
+index 4eee351..486a15a 100644
+--- a/arch/arm/kernel/head.S
++++ b/arch/arm/kernel/head.S
+@@ -246,6 +246,7 @@ __create_page_tables:
+ 
+ 	/*
+ 	 * Then map boot params address in r2 if specified.
++	 * We map 2 sections in case the ATAGs/DTB crosses a section boundary.
+ 	 */
+ 	mov	r0, r2, lsr #SECTION_SHIFT
+ 	movs	r0, r0, lsl #SECTION_SHIFT
+@@ -253,6 +254,8 @@ __create_page_tables:
+ 	addne	r3, r3, #PAGE_OFFSET
+ 	addne	r3, r4, r3, lsr #(SECTION_SHIFT - PMD_ORDER)
+ 	orrne	r6, r7, r0
++	strne	r6, [r3], #1 << PMD_ORDER
++	addne	r6, r6, #1 << SECTION_SHIFT
+ 	strne	r6, [r3]
+ 
+ #ifdef CONFIG_DEBUG_LL
+@@ -331,7 +334,7 @@ ENTRY(secondary_startup)
+ 	 * as it has already been validated by the primary processor.
+ 	 */
+ #ifdef CONFIG_ARM_VIRT_EXT
+-	bl	__hyp_stub_install
++	bl	__hyp_stub_install_secondary
+ #endif
+ 	safe_svcmode_maskall r9
+ 
+diff --git a/arch/arm/kernel/hyp-stub.S b/arch/arm/kernel/hyp-stub.S
+index 65b2417..1315c4c 100644
+--- a/arch/arm/kernel/hyp-stub.S
++++ b/arch/arm/kernel/hyp-stub.S
+@@ -99,7 +99,7 @@ ENTRY(__hyp_stub_install_secondary)
+ 	 * immediately.
+ 	 */
+ 	compare_cpu_mode_with_primary	r4, r5, r6, r7
+-	bxne	lr
++	movne	pc, lr
+ 
+ 	/*
+ 	 * Once we have given up on one CPU, we do not try to install the
+@@ -111,7 +111,7 @@ ENTRY(__hyp_stub_install_secondary)
+ 	 */
+ 
+ 	cmp	r4, #HYP_MODE
+-	bxne	lr			@ give up if the CPU is not in HYP mode
++	movne	pc, lr			@ give up if the CPU is not in HYP mode
+ 
+ /*
+  * Configure HSCTLR to set correct exception endianness/instruction set
+@@ -120,7 +120,8 @@ ENTRY(__hyp_stub_install_secondary)
+  * Eventually, CPU-specific code might be needed -- assume not for now
+  *
+  * This code relies on the "eret" instruction to synchronize the
+- * various coprocessor accesses.
++ * various coprocessor accesses. This is done when we switch to SVC
++ * (see safe_svcmode_maskall).
+  */
+ 	@ Now install the hypervisor stub:
+ 	adr	r7, __hyp_stub_vectors
+@@ -155,14 +156,7 @@ THUMB(	orr	r7, #(1 << 30)	)	@ HSCTLR.TE
+ 1:
+ #endif
+ 
+-	bic	r7, r4, #MODE_MASK
+-	orr	r7, r7, #SVC_MODE
+-THUMB(	orr	r7, r7, #PSR_T_BIT	)
+-	msr	spsr_cxsf, r7		@ This is SPSR_hyp.
+-
+-	__MSR_ELR_HYP(14)		@ msr elr_hyp, lr
+-	__ERET				@ return, switching to SVC mode
+-					@ The boot CPU mode is left in r4.
++	bx	lr			@ The boot CPU mode is left in r4.
+ ENDPROC(__hyp_stub_install_secondary)
+ 
+ __hyp_stub_do_trap:
+@@ -200,7 +194,7 @@ ENDPROC(__hyp_get_vectors)
+ 	@ fall through
+ ENTRY(__hyp_set_vectors)
+ 	__HVC(0)
+-	bx	lr
++	mov	pc, lr
+ ENDPROC(__hyp_set_vectors)
+ 
+ #ifndef ZIMAGE
 diff --git a/arch/arm/kernel/swp_emulate.c b/arch/arm/kernel/swp_emulate.c
 index df74518..ab1017b 100644
 --- a/arch/arm/kernel/swp_emulate.c
@@ -83,6 +179,19 @@
  
  	info.si_signo = SIGSEGV;
  	info.si_errno = 0;
+diff --git a/arch/arm/mach-at91/setup.c b/arch/arm/mach-at91/setup.c
+index 0b32c81..dee51da 100644
+--- a/arch/arm/mach-at91/setup.c
++++ b/arch/arm/mach-at91/setup.c
+@@ -104,6 +104,8 @@ static void __init soc_detect(u32 dbgu_base)
+ 	switch (socid) {
+ 	case ARCH_ID_AT91RM9200:
+ 		at91_soc_initdata.type = AT91_SOC_RM9200;
++		if (at91_soc_initdata.subtype == AT91_SOC_SUBTYPE_NONE)
++			at91_soc_initdata.subtype = AT91_SOC_RM9200_BGA;
+ 		at91_boot_soc = at91rm9200_soc;
+ 		break;
+ 
 diff --git a/arch/arm/mach-omap2/board-3430sdp.c b/arch/arm/mach-omap2/board-3430sdp.c
 index 96cd369..09e1790 100644
 --- a/arch/arm/mach-omap2/board-3430sdp.c
@@ -155,6 +264,23 @@
  };
  
  static struct omap_dss_device omap3_stalker_dvi_device = {
+diff --git a/arch/arm/mach-omap2/board-omap4panda.c b/arch/arm/mach-omap2/board-omap4panda.c
+index bfcd397..92bb6b4 100644
+--- a/arch/arm/mach-omap2/board-omap4panda.c
++++ b/arch/arm/mach-omap2/board-omap4panda.c
+@@ -402,6 +402,12 @@ static struct omap_board_mux board_mux[] __initdata = {
+ 		  OMAP_PULL_ENA),
+ 	OMAP4_MUX(ABE_MCBSP1_FSX, OMAP_MUX_MODE0 | OMAP_PIN_INPUT),
+ 
++	/* UART2 - BT/FM/GPS shared transport */
++	OMAP4_MUX(UART2_CTS,	OMAP_PIN_INPUT	| OMAP_MUX_MODE0),
++	OMAP4_MUX(UART2_RTS,	OMAP_PIN_OUTPUT	| OMAP_MUX_MODE0),
++	OMAP4_MUX(UART2_RX,	OMAP_PIN_INPUT	| OMAP_MUX_MODE0),
++	OMAP4_MUX(UART2_TX,	OMAP_PIN_OUTPUT	| OMAP_MUX_MODE0),
++
+ 	{ .reg_offset = OMAP_MUX_TERMINATOR },
+ };
+ 
 diff --git a/arch/arm/mach-pxa/include/mach/mfp-pxa27x.h b/arch/arm/mach-pxa/include/mach/mfp-pxa27x.h
 index a611ad3..b6132aa 100644
 --- a/arch/arm/mach-pxa/include/mach/mfp-pxa27x.h
@@ -198,6 +324,19 @@
  #define REALVIEW_EB11MP_L220_BASE	0x10102000	/* L220 registers */
  #define REALVIEW_EB11MP_SYS_PLD_CTRL1	0xD8		/* Register offset for MPCore sysctl */
  #else
+diff --git a/arch/arm/mach-s3c64xx/mach-crag6410-module.c b/arch/arm/mach-s3c64xx/mach-crag6410-module.c
+index 4e3fe57..cbc1b7b 100644
+--- a/arch/arm/mach-s3c64xx/mach-crag6410-module.c
++++ b/arch/arm/mach-s3c64xx/mach-crag6410-module.c
+@@ -39,7 +39,7 @@ static struct spi_board_info wm1253_devs[] = {
+ 		.bus_num	= 0,
+ 		.chip_select	= 0,
+ 		.mode		= SPI_MODE_0,
+-		.irq		= S3C_EINT(5),
++		.irq		= S3C_EINT(4),
+ 		.controller_data = &wm0010_spi_csinfo,
+ 	},
+ };
 diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
 index cd95664..7539ec2 100644
 --- a/arch/arm/mm/cache-v7.S
@@ -215,6 +354,54 @@
  	moveq	pc, lr				@ return if level == 0
  	mov	r10, #0				@ r10 (starting level) = 0
  	b	flush_levels			@ start flushing cache levels
+diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
+index 58bc3e4..9cb586f 100644
+--- a/arch/arm/mm/dma-mapping.c
++++ b/arch/arm/mm/dma-mapping.c
+@@ -776,25 +776,27 @@ static void dma_cache_maint_page(struct page *page, unsigned long offset,
+ 	size_t size, enum dma_data_direction dir,
+ 	void (*op)(const void *, size_t, int))
+ {
++	unsigned long pfn;
++	size_t left = size;
++
++	pfn = page_to_pfn(page) + offset / PAGE_SIZE;
++	offset %= PAGE_SIZE;
++
+ 	/*
+ 	 * A single sg entry may refer to multiple physically contiguous
+ 	 * pages.  But we still need to process highmem pages individually.
+ 	 * If highmem is not configured then the bulk of this loop gets
+ 	 * optimized out.
+ 	 */
+-	size_t left = size;
+ 	do {
+ 		size_t len = left;
+ 		void *vaddr;
+ 
++		page = pfn_to_page(pfn);
++
+ 		if (PageHighMem(page)) {
+-			if (len + offset > PAGE_SIZE) {
+-				if (offset >= PAGE_SIZE) {
+-					page += offset / PAGE_SIZE;
+-					offset %= PAGE_SIZE;
+-				}
++			if (len + offset > PAGE_SIZE)
+ 				len = PAGE_SIZE - offset;
+-			}
+ 			vaddr = kmap_high_get(page);
+ 			if (vaddr) {
+ 				vaddr += offset;
+@@ -811,7 +813,7 @@ static void dma_cache_maint_page(struct page *page, unsigned long offset,
+ 			op(vaddr, len, dir);
+ 		}
+ 		offset = 0;
+-		page++;
++		pfn++;
+ 		left -= len;
+ 	} while (left);
+ }
 diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
 index 941dfb9..99b47b9 100644
 --- a/arch/arm/mm/mmu.c
@@ -228,6 +415,59 @@
  		protection_map[i] = __pgprot(v | user_pgprot);
  	}
  
+diff --git a/arch/arm/vfp/entry.S b/arch/arm/vfp/entry.S
+index cc926c9..323ce1a 100644
+--- a/arch/arm/vfp/entry.S
++++ b/arch/arm/vfp/entry.S
+@@ -22,7 +22,7 @@
+ @  IRQs disabled.
+ @
+ ENTRY(do_vfp)
+-#ifdef CONFIG_PREEMPT
++#ifdef CONFIG_PREEMPT_COUNT
+ 	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+ 	add	r11, r4, #1		@ increment it
+ 	str	r11, [r10, #TI_PREEMPT]
+@@ -35,7 +35,7 @@ ENTRY(do_vfp)
+ ENDPROC(do_vfp)
+ 
+ ENTRY(vfp_null_entry)
+-#ifdef CONFIG_PREEMPT
++#ifdef CONFIG_PREEMPT_COUNT
+ 	get_thread_info	r10
+ 	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+ 	sub	r11, r4, #1		@ decrement it
+@@ -53,7 +53,7 @@ ENDPROC(vfp_null_entry)
+ 
+ 	__INIT
+ ENTRY(vfp_testing_entry)
+-#ifdef CONFIG_PREEMPT
++#ifdef CONFIG_PREEMPT_COUNT
+ 	get_thread_info	r10
+ 	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+ 	sub	r11, r4, #1		@ decrement it
+diff --git a/arch/arm/vfp/vfphw.S b/arch/arm/vfp/vfphw.S
+index ea0349f..dd5e56f 100644
+--- a/arch/arm/vfp/vfphw.S
++++ b/arch/arm/vfp/vfphw.S
+@@ -168,7 +168,7 @@ vfp_hw_state_valid:
+ 					@ else it's one 32-bit instruction, so
+ 					@ always subtract 4 from the following
+ 					@ instruction address.
+-#ifdef CONFIG_PREEMPT
++#ifdef CONFIG_PREEMPT_COUNT
+ 	get_thread_info	r10
+ 	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+ 	sub	r11, r4, #1		@ decrement it
+@@ -192,7 +192,7 @@ look_for_VFP_exceptions:
+ 	@ not recognised by VFP
+ 
+ 	DBGSTR	"not VFP"
+-#ifdef CONFIG_PREEMPT
++#ifdef CONFIG_PREEMPT_COUNT
+ 	get_thread_info	r10
+ 	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
+ 	sub	r11, r4, #1		@ decrement it
 diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h
 index 07fea29..fe32c0e 100644
 --- a/arch/arm64/include/asm/elf.h
@@ -476,6 +716,30 @@
  	/*
  	 * Bug workaround for the Nevada. It seems as if under certain
  	 * circumstances the move from cp0_context might produce a
+diff --git a/arch/powerpc/kernel/entry_64.S b/arch/powerpc/kernel/entry_64.S
+index 56e0ff0..4262aac 100644
+--- a/arch/powerpc/kernel/entry_64.S
++++ b/arch/powerpc/kernel/entry_64.S
+@@ -668,6 +668,19 @@ resume_kernel:
+ 	ld	r4,TI_FLAGS(r9)
+ 	andi.	r0,r4,_TIF_NEED_RESCHED
+ 	bne	1b
++
++	/*
++	 * arch_local_irq_restore() from preempt_schedule_irq above may
++	 * enable hard interrupt but we really should disable interrupts
++	 * when we return from the interrupt, and so that we don't get
++	 * interrupted after loading SRR0/1.
++	 */
++#ifdef CONFIG_PPC_BOOK3E
++	wrteei	0
++#else
++	ld	r10,PACAKMSR(r13) /* Get kernel MSR without EE */
++	mtmsrd	r10,1		  /* Update machine state */
++#endif /* CONFIG_PPC_BOOK3E */
+ #endif /* CONFIG_PREEMPT */
+ 
+ 	.globl	fast_exc_return_irq
 diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S
 index 58bddee..9e07bd0 100644
 --- a/arch/powerpc/kernel/head_64.S
@@ -540,6 +804,26 @@
  					  vcpu_e500->gtlb_params[1].entries,
  					  GFP_KERNEL);
  	if (!vcpu_e500->g2h_tlb1_map)
+diff --git a/arch/powerpc/kvm/emulate.c b/arch/powerpc/kvm/emulate.c
+index ee04aba..f6ba56f 100644
+--- a/arch/powerpc/kvm/emulate.c
++++ b/arch/powerpc/kvm/emulate.c
+@@ -39,6 +39,7 @@
+ #define OP_31_XOP_TRAP      4
+ #define OP_31_XOP_LWZX      23
+ #define OP_31_XOP_TRAP_64   68
++#define OP_31_XOP_DCBF      86
+ #define OP_31_XOP_LBZX      87
+ #define OP_31_XOP_STWX      151
+ #define OP_31_XOP_STBX      215
+@@ -353,6 +354,7 @@ int kvmppc_emulate_instruction(struct kvm_run *run, struct kvm_vcpu *vcpu)
+ 			kvmppc_set_exit_type(vcpu, EMULATED_MTSPR_EXITS);
+ 			break;
+ 
++		case OP_31_XOP_DCBF:
+ 		case OP_31_XOP_DCBI:
+ 			/* Do nothing. The guest is performing dcbi because
+ 			 * hardware DMA is not snooped by the dcache, but
 diff --git a/arch/powerpc/platforms/40x/ppc40x_simple.c b/arch/powerpc/platforms/40x/ppc40x_simple.c
 index 969dddc..8f3920e 100644
 --- a/arch/powerpc/platforms/40x/ppc40x_simple.c
@@ -554,6 +838,29 @@
  };
  
  static int __init ppc40x_probe(void)
+diff --git a/arch/s390/include/asm/pgtable.h b/arch/s390/include/asm/pgtable.h
+index 2d3b7cb..80d44ff 100644
+--- a/arch/s390/include/asm/pgtable.h
++++ b/arch/s390/include/asm/pgtable.h
+@@ -1365,6 +1365,18 @@ static inline void pmdp_invalidate(struct vm_area_struct *vma,
+ 	__pmd_idte(address, pmdp);
+ }
+ 
++#define __HAVE_ARCH_PMDP_SET_WRPROTECT
++static inline void pmdp_set_wrprotect(struct mm_struct *mm,
++				      unsigned long address, pmd_t *pmdp)
++{
++	pmd_t pmd = *pmdp;
++
++	if (pmd_write(pmd)) {
++		__pmd_idte(address, pmdp);
++		set_pmd_at(mm, address, pmdp, pmd_wrprotect(pmd));
++	}
++}
++
+ static inline pmd_t mk_pmd_phys(unsigned long physpage, pgprot_t pgprot)
+ {
+ 	pmd_t __pmd;
 diff --git a/arch/s390/include/asm/timex.h b/arch/s390/include/asm/timex.h
 index fba4d66..4c060bb 100644
 --- a/arch/s390/include/asm/timex.h
@@ -999,6 +1306,49 @@
  }
  
  static inline pte_t huge_ptep_get(pte_t *ptep)
+diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c
+index e87b0ca..ccae7e2 100644
+--- a/arch/x86/boot/compressed/eboot.c
++++ b/arch/x86/boot/compressed/eboot.c
+@@ -316,10 +316,9 @@ static efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,
+ 			 * Once we've found a GOP supporting ConOut,
+ 			 * don't bother looking any further.
+ 			 */
++			first_gop = gop;
+ 			if (conout_found)
+ 				break;
+-
+-			first_gop = gop;
+ 		}
+ 	}
+ 
+diff --git a/arch/x86/boot/compressed/head_32.S b/arch/x86/boot/compressed/head_32.S
+index aa4aaf1..ccb2f4a 100644
+--- a/arch/x86/boot/compressed/head_32.S
++++ b/arch/x86/boot/compressed/head_32.S
+@@ -50,8 +50,10 @@ ENTRY(startup_32)
+ 	pushl	%eax
+ 	pushl	%esi
+ 	pushl	%ecx
++	sub	$0x4, %esp
+ 
+ 	.org 0x30,0x90
++	add	$0x4, %esp
+ 	call	efi_main
+ 	cmpl	$0, %eax
+ 	movl	%eax, %esi
+diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h
+index 6e8fdf5..28677c5 100644
+--- a/arch/x86/include/asm/efi.h
++++ b/arch/x86/include/asm/efi.h
+@@ -94,6 +94,7 @@ extern void __iomem *efi_ioremap(unsigned long addr, unsigned long size,
+ #endif /* CONFIG_X86_32 */
+ 
+ extern int add_efi_memmap;
++extern unsigned long x86_efi_facility;
+ extern void efi_set_executable(efi_memory_desc_t *md, bool executable);
+ extern int efi_memblock_x86_reserve_range(void);
+ extern void efi_call_phys_prelog(void);
 diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c
 index 4a3374e..d18b2b8 100644
 --- a/arch/x86/kernel/cpu/perf_event.c
@@ -1057,16 +1407,44 @@
  	hpet_writel(cfg, HPET_Tn_CFG(hdev->num));
  }
  
+diff --git a/arch/x86/kernel/msr.c b/arch/x86/kernel/msr.c
+index a7c5661..4929502 100644
+--- a/arch/x86/kernel/msr.c
++++ b/arch/x86/kernel/msr.c
+@@ -174,6 +174,9 @@ static int msr_open(struct inode *inode, struct file *file)
+ 	unsigned int cpu;
+ 	struct cpuinfo_x86 *c;
+ 
++	if (!capable(CAP_SYS_RAWIO))
++		return -EPERM;
++
+ 	cpu = iminor(file->f_path.dentry->d_inode);
+ 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
+ 		return -ENXIO;	/* No such CPU */
+diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c
+index 4e8ba39..76fa1e9 100644
+--- a/arch/x86/kernel/reboot.c
++++ b/arch/x86/kernel/reboot.c
+@@ -584,7 +584,7 @@ static void native_machine_emergency_restart(void)
+ 			break;
+ 
+ 		case BOOT_EFI:
+-			if (efi_enabled)
++			if (efi_enabled(EFI_RUNTIME_SERVICES))
+ 				efi.reset_system(reboot_mode ?
+ 						 EFI_RESET_WARM :
+ 						 EFI_RESET_COLD,
 diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
-index ca45696..86c524c 100644
+index ca45696..aeacb0e 100644
 --- a/arch/x86/kernel/setup.c
 +++ b/arch/x86/kernel/setup.c
-@@ -614,6 +614,81 @@ static __init void reserve_ibft_region(void)
+@@ -614,6 +614,83 @@ static __init void reserve_ibft_region(void)
  
  static unsigned reserve_low = CONFIG_X86_RESERVE_LOW << 10;
  
 +static bool __init snb_gfx_workaround_needed(void)
 +{
++#ifdef CONFIG_PCI
 +	int i;
 +	u16 vendor, devid;
 +	static const u16 snb_ids[] = {
@@ -1091,6 +1469,7 @@
 +	for (i = 0; i < ARRAY_SIZE(snb_ids); i++)
 +		if (devid == snb_ids[i])
 +			return true;
++#endif
 +
 +	return false;
 +}
@@ -1143,7 +1522,7 @@
  static void __init trim_bios_range(void)
  {
  	/*
-@@ -634,6 +709,7 @@ static void __init trim_bios_range(void)
+@@ -634,6 +711,7 @@ static void __init trim_bios_range(void)
  	 * take them out.
  	 */
  	e820_remove_range(BIOS_BEGIN, BIOS_END - BIOS_BEGIN, E820_RAM, 1);
@@ -1151,7 +1530,47 @@
  	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
  }
  
-@@ -912,6 +988,8 @@ void __init setup_arch(char **cmdline_p)
+@@ -733,15 +811,15 @@ void __init setup_arch(char **cmdline_p)
+ #ifdef CONFIG_EFI
+ 	if (!strncmp((char *)&boot_params.efi_info.efi_loader_signature,
+ 		     "EL32", 4)) {
+-		efi_enabled = 1;
+-		efi_64bit = false;
++		set_bit(EFI_BOOT, &x86_efi_facility);
+ 	} else if (!strncmp((char *)&boot_params.efi_info.efi_loader_signature,
+ 		     "EL64", 4)) {
+-		efi_enabled = 1;
+-		efi_64bit = true;
++		set_bit(EFI_BOOT, &x86_efi_facility);
++		set_bit(EFI_64BIT, &x86_efi_facility);
+ 	}
+-	if (efi_enabled && efi_memblock_x86_reserve_range())
+-		efi_enabled = 0;
++
++	if (efi_enabled(EFI_BOOT))
++		efi_memblock_x86_reserve_range();
+ #endif
+ 
+ 	x86_init.oem.arch_setup();
+@@ -814,7 +892,7 @@ void __init setup_arch(char **cmdline_p)
+ 
+ 	finish_e820_parsing();
+ 
+-	if (efi_enabled)
++	if (efi_enabled(EFI_BOOT))
+ 		efi_init();
+ 
+ 	dmi_scan_machine();
+@@ -897,7 +975,7 @@ void __init setup_arch(char **cmdline_p)
+ 	 * The EFI specification says that boot service code won't be called
+ 	 * after ExitBootServices(). This is, in fact, a lie.
+ 	 */
+-	if (efi_enabled)
++	if (efi_enabled(EFI_MEMMAP))
+ 		efi_reserve_boot_services();
+ 
+ 	/* preallocate 4k for mptable mpc */
+@@ -912,6 +990,8 @@ void __init setup_arch(char **cmdline_p)
  
  	setup_real_mode();
  
@@ -1160,6 +1579,35 @@
  	init_gbpages();
  
  	/* max_pfn_mapped is updated here */
+@@ -1034,7 +1114,7 @@ void __init setup_arch(char **cmdline_p)
+ 
+ #ifdef CONFIG_VT
+ #if defined(CONFIG_VGA_CONSOLE)
+-	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
++	if (!efi_enabled(EFI_BOOT) || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
+ 		conswitchp = &vga_con;
+ #elif defined(CONFIG_DUMMY_CONSOLE)
+ 	conswitchp = &dummy_con;
+@@ -1051,14 +1131,14 @@ void __init setup_arch(char **cmdline_p)
+ 	register_refined_jiffies(CLOCK_TICK_RATE);
+ 
+ #ifdef CONFIG_EFI
+-	/* Once setup is done above, disable efi_enabled on mismatched
+-	 * firmware/kernel archtectures since there is no support for
+-	 * runtime services.
++	/* Once setup is done above, unmap the EFI memory map on
++	 * mismatched firmware/kernel archtectures since there is no
++	 * support for runtime services.
+ 	 */
+-	if (efi_enabled && IS_ENABLED(CONFIG_X86_64) != efi_64bit) {
++	if (efi_enabled(EFI_BOOT) &&
++	    IS_ENABLED(CONFIG_X86_64) != efi_enabled(EFI_64BIT)) {
+ 		pr_info("efi: Setup done, disabling due to 32/64-bit mismatch\n");
+ 		efi_unmap_memmap();
+-		efi_enabled = 0;
+ 	}
+ #endif
+ }
 diff --git a/arch/x86/kernel/step.c b/arch/x86/kernel/step.c
 index cd3b243..9b4d51d 100644
 --- a/arch/x86/kernel/step.c
@@ -1194,6 +1642,217 @@
  		},
  	},
  	{}
+diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c
+index ad44391..77cf009 100644
+--- a/arch/x86/platform/efi/efi.c
++++ b/arch/x86/platform/efi/efi.c
+@@ -51,9 +51,6 @@
+ 
+ #define EFI_DEBUG	1
+ 
+-int efi_enabled;
+-EXPORT_SYMBOL(efi_enabled);
+-
+ struct efi __read_mostly efi = {
+ 	.mps        = EFI_INVALID_TABLE_ADDR,
+ 	.acpi       = EFI_INVALID_TABLE_ADDR,
+@@ -69,19 +66,28 @@ EXPORT_SYMBOL(efi);
+ 
+ struct efi_memory_map memmap;
+ 
+-bool efi_64bit;
+-
+ static struct efi efi_phys __initdata;
+ static efi_system_table_t efi_systab __initdata;
+ 
+ static inline bool efi_is_native(void)
+ {
+-	return IS_ENABLED(CONFIG_X86_64) == efi_64bit;
++	return IS_ENABLED(CONFIG_X86_64) == efi_enabled(EFI_64BIT);
++}
++
++unsigned long x86_efi_facility;
++
++/*
++ * Returns 1 if 'facility' is enabled, 0 otherwise.
++ */
++int efi_enabled(int facility)
++{
++	return test_bit(facility, &x86_efi_facility) != 0;
+ }
++EXPORT_SYMBOL(efi_enabled);
+ 
+ static int __init setup_noefi(char *arg)
+ {
+-	efi_enabled = 0;
++	clear_bit(EFI_BOOT, &x86_efi_facility);
+ 	return 0;
+ }
+ early_param("noefi", setup_noefi);
+@@ -426,6 +432,7 @@ void __init efi_reserve_boot_services(void)
+ 
+ void __init efi_unmap_memmap(void)
+ {
++	clear_bit(EFI_MEMMAP, &x86_efi_facility);
+ 	if (memmap.map) {
+ 		early_iounmap(memmap.map, memmap.nr_map * memmap.desc_size);
+ 		memmap.map = NULL;
+@@ -460,7 +467,7 @@ void __init efi_free_boot_services(void)
+ 
+ static int __init efi_systab_init(void *phys)
+ {
+-	if (efi_64bit) {
++	if (efi_enabled(EFI_64BIT)) {
+ 		efi_system_table_64_t *systab64;
+ 		u64 tmp = 0;
+ 
+@@ -552,7 +559,7 @@ static int __init efi_config_init(u64 tables, int nr_tables)
+ 	void *config_tables, *tablep;
+ 	int i, sz;
+ 
+-	if (efi_64bit)
++	if (efi_enabled(EFI_64BIT))
+ 		sz = sizeof(efi_config_table_64_t);
+ 	else
+ 		sz = sizeof(efi_config_table_32_t);
+@@ -572,7 +579,7 @@ static int __init efi_config_init(u64 tables, int nr_tables)
+ 		efi_guid_t guid;
+ 		unsigned long table;
+ 
+-		if (efi_64bit) {
++		if (efi_enabled(EFI_64BIT)) {
+ 			u64 table64;
+ 			guid = ((efi_config_table_64_t *)tablep)->guid;
+ 			table64 = ((efi_config_table_64_t *)tablep)->table;
+@@ -684,7 +691,6 @@ void __init efi_init(void)
+ 	if (boot_params.efi_info.efi_systab_hi ||
+ 	    boot_params.efi_info.efi_memmap_hi) {
+ 		pr_info("Table located above 4GB, disabling EFI.\n");
+-		efi_enabled = 0;
+ 		return;
+ 	}
+ 	efi_phys.systab = (efi_system_table_t *)boot_params.efi_info.efi_systab;
+@@ -694,10 +700,10 @@ void __init efi_init(void)
+ 			  ((__u64)boot_params.efi_info.efi_systab_hi<<32));
+ #endif
+ 
+-	if (efi_systab_init(efi_phys.systab)) {
+-		efi_enabled = 0;
++	if (efi_systab_init(efi_phys.systab))
+ 		return;
+-	}
++
++	set_bit(EFI_SYSTEM_TABLES, &x86_efi_facility);
+ 
+ 	/*
+ 	 * Show what we know for posterity
+@@ -715,10 +721,10 @@ void __init efi_init(void)
+ 		efi.systab->hdr.revision >> 16,
+ 		efi.systab->hdr.revision & 0xffff, vendor);
+ 
+-	if (efi_config_init(efi.systab->tables, efi.systab->nr_tables)) {
+-		efi_enabled = 0;
++	if (efi_config_init(efi.systab->tables, efi.systab->nr_tables))
+ 		return;
+-	}
++
++	set_bit(EFI_CONFIG_TABLES, &x86_efi_facility);
+ 
+ 	/*
+ 	 * Note: We currently don't support runtime services on an EFI
+@@ -727,15 +733,17 @@ void __init efi_init(void)
+ 
+ 	if (!efi_is_native())
+ 		pr_info("No EFI runtime due to 32/64-bit mismatch with kernel\n");
+-	else if (efi_runtime_init()) {
+-		efi_enabled = 0;
+-		return;
++	else {
++		if (efi_runtime_init())
++			return;
++		set_bit(EFI_RUNTIME_SERVICES, &x86_efi_facility);
+ 	}
+ 
+-	if (efi_memmap_init()) {
+-		efi_enabled = 0;
++	if (efi_memmap_init())
+ 		return;
+-	}
++
++	set_bit(EFI_MEMMAP, &x86_efi_facility);
++
+ #ifdef CONFIG_X86_32
+ 	if (efi_is_native()) {
+ 		x86_platform.get_wallclock = efi_get_time;
+@@ -941,7 +949,7 @@ void __init efi_enter_virtual_mode(void)
+ 	 *
+ 	 * Call EFI services through wrapper functions.
+ 	 */
+-	efi.runtime_version = efi_systab.fw_revision;
++	efi.runtime_version = efi_systab.hdr.revision;
+ 	efi.get_time = virt_efi_get_time;
+ 	efi.set_time = virt_efi_set_time;
+ 	efi.get_wakeup_time = virt_efi_get_wakeup_time;
+@@ -969,6 +977,9 @@ u32 efi_mem_type(unsigned long phys_addr)
+ 	efi_memory_desc_t *md;
+ 	void *p;
+ 
++	if (!efi_enabled(EFI_MEMMAP))
++		return 0;
++
+ 	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
+ 		md = p;
+ 		if ((md->phys_addr <= phys_addr) &&
+diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c
+index 95fd505..2b20038 100644
+--- a/arch/x86/platform/efi/efi_64.c
++++ b/arch/x86/platform/efi/efi_64.c
+@@ -38,7 +38,7 @@
+ #include <asm/cacheflush.h>
+ #include <asm/fixmap.h>
+ 
+-static pgd_t save_pgd __initdata;
++static pgd_t *save_pgd __initdata;
+ static unsigned long efi_flags __initdata;
+ 
+ static void __init early_code_mapping_set_exec(int executable)
+@@ -61,12 +61,20 @@ static void __init early_code_mapping_set_exec(int executable)
+ void __init efi_call_phys_prelog(void)
+ {
+ 	unsigned long vaddress;
++	int pgd;
++	int n_pgds;
+ 
+ 	early_code_mapping_set_exec(1);
+ 	local_irq_save(efi_flags);
+-	vaddress = (unsigned long)__va(0x0UL);
+-	save_pgd = *pgd_offset_k(0x0UL);
+-	set_pgd(pgd_offset_k(0x0UL), *pgd_offset_k(vaddress));
++
++	n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);
++	save_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);
++
++	for (pgd = 0; pgd < n_pgds; pgd++) {
++		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);
++		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);
++		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));
++	}
+ 	__flush_tlb_all();
+ }
+ 
+@@ -75,7 +83,11 @@ void __init efi_call_phys_epilog(void)
+ 	/*
+ 	 * After the lock is released, the original page table is restored.
+ 	 */
+-	set_pgd(pgd_offset_k(0x0UL), save_pgd);
++	int pgd;
++	int n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT) , PGDIR_SIZE);
++	for (pgd = 0; pgd < n_pgds; pgd++)
++		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), save_pgd[pgd]);
++	kfree(save_pgd);
+ 	__flush_tlb_all();
+ 	local_irq_restore(efi_flags);
+ 	early_code_mapping_set_exec(0);
 diff --git a/drivers/acpi/battery.c b/drivers/acpi/battery.c
 index 45e3e17..7efaeaa 100644
 --- a/drivers/acpi/battery.c
@@ -1317,6 +1976,19 @@
  }
  
  static int acpi_battery_update(struct acpi_battery *battery)
+diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
+index 9eaf708..251435a 100644
+--- a/drivers/acpi/osl.c
++++ b/drivers/acpi/osl.c
+@@ -250,7 +250,7 @@ acpi_physical_address __init acpi_os_get_root_pointer(void)
+ 		return acpi_rsdp;
+ #endif
+ 
+-	if (efi_enabled) {
++	if (efi_enabled(EFI_CONFIG_TABLES)) {
+ 		if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
+ 			return efi.acpi20;
+ 		else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
 diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
 index e8086c7..53dc256 100644
 --- a/drivers/acpi/processor_idle.c
@@ -2661,6 +3333,19 @@
 +	put_device(mci_pdev);
  	edac_put_sysfs_subsys();
  }
+diff --git a/drivers/edac/edac_pci_sysfs.c b/drivers/edac/edac_pci_sysfs.c
+index e164c55..1bfb207 100644
+--- a/drivers/edac/edac_pci_sysfs.c
++++ b/drivers/edac/edac_pci_sysfs.c
+@@ -256,7 +256,7 @@ static ssize_t edac_pci_dev_store(struct kobject *kobj,
+ 	struct edac_pci_dev_attribute *edac_pci_dev;
+ 	edac_pci_dev = (struct edac_pci_dev_attribute *)attr;
+ 
+-	if (edac_pci_dev->show)
++	if (edac_pci_dev->store)
+ 		return edac_pci_dev->store(edac_pci_dev->value, buffer, count);
+ 	return -EIO;
+ }
 diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c
 index 08c6749..638e1f7 100644
 --- a/drivers/firewire/net.c
@@ -2700,7 +3385,7 @@
  		put_unaligned_be32((IANA_SPECIFIER_ID & 0xff) << 24
  						| RFC2734_SW_VERSION, &p[4]);
 diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c
-index b298158..fd3ae62 100644
+index b298158..982f1f5 100644
 --- a/drivers/firmware/dmi_scan.c
 +++ b/drivers/firmware/dmi_scan.c
 @@ -16,6 +16,7 @@
@@ -2756,7 +3441,7 @@
  
          dmi_ident[slot] = s;
  }
-@@ -404,29 +415,57 @@ static int __init dmi_present(const char __iomem *p)
+@@ -404,35 +415,63 @@ static int __init dmi_present(const char __iomem *p)
  	u8 buf[15];
  
  	memcpy_fromio(buf, p, 15);
@@ -2824,6 +3509,13 @@
  void __init dmi_scan_machine(void)
  {
  	char __iomem *p, *q;
+ 	int rc;
+ 
+-	if (efi_enabled) {
++	if (efi_enabled(EFI_CONFIG_TABLES)) {
+ 		if (efi.smbios == EFI_INVALID_TABLE_ADDR)
+ 			goto error;
+ 
 @@ -444,7 +483,7 @@ void __init dmi_scan_machine(void)
  		if (p == NULL)
  			goto error;
@@ -2847,6 +3539,41 @@
  			if (!rc) {
  				dmi_available = 1;
  				dmi_iounmap(p, 0x10000);
+diff --git a/drivers/firmware/efivars.c b/drivers/firmware/efivars.c
+index d10c987..bfd8f43 100644
+--- a/drivers/firmware/efivars.c
++++ b/drivers/firmware/efivars.c
+@@ -1224,7 +1224,7 @@ efivars_init(void)
+ 	printk(KERN_INFO "EFI Variables Facility v%s %s\n", EFIVARS_VERSION,
+ 	       EFIVARS_DATE);
+ 
+-	if (!efi_enabled)
++	if (!efi_enabled(EFI_RUNTIME_SERVICES))
+ 		return 0;
+ 
+ 	/* For now we'll register the efi directory at /sys/firmware/efi */
+@@ -1262,7 +1262,7 @@ err_put:
+ static void __exit
+ efivars_exit(void)
+ {
+-	if (efi_enabled) {
++	if (efi_enabled(EFI_RUNTIME_SERVICES)) {
+ 		unregister_efivars(&__efivars);
+ 		kobject_put(efi_kobj);
+ 	}
+diff --git a/drivers/firmware/iscsi_ibft_find.c b/drivers/firmware/iscsi_ibft_find.c
+index 4da4eb9..2224f1d 100644
+--- a/drivers/firmware/iscsi_ibft_find.c
++++ b/drivers/firmware/iscsi_ibft_find.c
+@@ -99,7 +99,7 @@ unsigned long __init find_ibft_region(unsigned long *sizep)
+ 	/* iBFT 1.03 section 1.4.3.1 mandates that UEFI machines will
+ 	 * only use ACPI for this */
+ 
+-	if (!efi_enabled)
++	if (!efi_enabled(EFI_BOOT))
+ 		find_ibft_in_mem();
+ 
+ 	if (ibft_addr) {
 diff --git a/drivers/gpu/drm/drm_mm.c b/drivers/gpu/drm/drm_mm.c
 index 0761a03..665553c 100644
 --- a/drivers/gpu/drm/drm_mm.c
@@ -2970,10 +3697,18 @@
  		}
  	}
 diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
-index dde8b50..da21b11 100644
+index dde8b50..3a1a495 100644
 --- a/drivers/gpu/drm/i915/i915_debugfs.c
 +++ b/drivers/gpu/drm/i915/i915_debugfs.c
-@@ -317,7 +317,7 @@ static int i915_gem_pageflip_info(struct seq_file *m, void *data)
+@@ -30,6 +30,7 @@
+ #include <linux/debugfs.h>
+ #include <linux/slab.h>
+ #include <linux/export.h>
++#include <generated/utsrelease.h>
+ #include <drm/drmP.h>
+ #include "intel_drv.h"
+ #include "intel_ringbuffer.h"
+@@ -317,7 +318,7 @@ static int i915_gem_pageflip_info(struct seq_file *m, void *data)
  			seq_printf(m, "No flip due on pipe %c (plane %c)\n",
  				   pipe, plane);
  		} else {
@@ -2982,7 +3717,7 @@
  				seq_printf(m, "Flip queued on pipe %c (plane %c)\n",
  					   pipe, plane);
  			} else {
-@@ -328,7 +328,7 @@ static int i915_gem_pageflip_info(struct seq_file *m, void *data)
+@@ -328,7 +329,7 @@ static int i915_gem_pageflip_info(struct seq_file *m, void *data)
  				seq_printf(m, "Stall check enabled, ");
  			else
  				seq_printf(m, "Stall check waiting for page flip ioctl, ");
@@ -2991,6 +3726,14 @@
  
  			if (work->old_fb_obj) {
  				struct drm_i915_gem_object *obj = work->old_fb_obj;
+@@ -687,6 +688,7 @@ static int i915_error_state(struct seq_file *m, void *unused)
+ 
+ 	seq_printf(m, "Time: %ld s %ld us\n", error->time.tv_sec,
+ 		   error->time.tv_usec);
++	seq_printf(m, "Kernel: " UTS_RELEASE);
+ 	seq_printf(m, "PCI ID: 0x%04x\n", dev->pci_device);
+ 	seq_printf(m, "EIR: 0x%08x\n", error->eir);
+ 	seq_printf(m, "IER: 0x%08x\n", error->ier);
 diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
 index 6770ee6..1f20ead 100644
 --- a/drivers/gpu/drm/i915/i915_drv.c
@@ -3182,7 +3925,7 @@
  		spin_unlock_irqrestore(&dev->event_lock, flags);
  		return;
 diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
-index a4162dd..ecec134 100644
+index a4162dd..3a43405 100644
 --- a/drivers/gpu/drm/i915/i915_reg.h
 +++ b/drivers/gpu/drm/i915/i915_reg.h
 @@ -514,6 +514,7 @@
@@ -3193,7 +3936,15 @@
  #define _3D_CHICKEN2	0x0208c
  /* Disables pipelining of read flushes past the SF-WIZ interface.
   * Required on all Ironlake steppings according to the B-Spec, but the
-@@ -3315,6 +3316,8 @@
+@@ -526,6 +527,7 @@
+ #define MI_MODE		0x0209c
+ # define VS_TIMER_DISPATCH				(1 << 6)
+ # define MI_FLUSH_ENABLE				(1 << 12)
++# define ASYNC_FLIP_PERF_DISABLE			(1 << 14)
+ 
+ #define GEN6_GT_MODE	0x20d0
+ #define   GEN6_GT_MODE_HI	(1 << 9)
+@@ -3315,6 +3317,8 @@
  #define _PFA_CTL_1               0x68080
  #define _PFB_CTL_1               0x68880
  #define  PF_ENABLE              (1<<31)
@@ -3578,7 +4329,7 @@
  		.matches = {
  			DMI_MATCH(DMI_BOARD_VENDOR, "Gigabyte Technology Co., Ltd."),
 diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c
-index 442968f..e87fa47 100644
+index 442968f..4e6a2b2 100644
 --- a/drivers/gpu/drm/i915/intel_pm.c
 +++ b/drivers/gpu/drm/i915/intel_pm.c
 @@ -44,6 +44,14 @@
@@ -3664,6 +4415,91 @@
  	I915_WRITE(WM3_LP_ILK, 0);
  	I915_WRITE(WM2_LP_ILK, 0);
  	I915_WRITE(WM1_LP_ILK, 0);
+@@ -4007,7 +4018,8 @@ static void __gen6_gt_force_wake_get(struct drm_i915_private *dev_priv)
+ 		DRM_ERROR("Timed out waiting for forcewake old ack to clear.\n");
+ 
+ 	I915_WRITE_NOTRACE(FORCEWAKE, 1);
+-	POSTING_READ(ECOBUS); /* something from same cacheline, but !FORCEWAKE */
++	/* something from same cacheline, but !FORCEWAKE */
++	POSTING_READ(ECOBUS);
+ 
+ 	if (wait_for_atomic((I915_READ_NOTRACE(forcewake_ack) & 1),
+ 			    FORCEWAKE_ACK_TIMEOUT_MS))
+@@ -4030,7 +4042,8 @@ static void __gen6_gt_force_wake_mt_get(struct drm_i915_private *dev_priv)
+ 		DRM_ERROR("Timed out waiting for forcewake old ack to clear.\n");
+ 
+ 	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_ENABLE(1));
+-	POSTING_READ(ECOBUS); /* something from same cacheline, but !FORCEWAKE */
++	/* something from same cacheline, but !FORCEWAKE */
++	POSTING_READ(ECOBUS);
+ 
+ 	if (wait_for_atomic((I915_READ_NOTRACE(forcewake_ack) & 1),
+ 			    FORCEWAKE_ACK_TIMEOUT_MS))
+@@ -4067,14 +4080,16 @@ void gen6_gt_check_fifodbg(struct drm_i915_private *dev_priv)
+ static void __gen6_gt_force_wake_put(struct drm_i915_private *dev_priv)
+ {
+ 	I915_WRITE_NOTRACE(FORCEWAKE, 0);
+-	/* gen6_gt_check_fifodbg doubles as the POSTING_READ */
++	/* something from same cacheline, but !FORCEWAKE */
++	POSTING_READ(ECOBUS);
+ 	gen6_gt_check_fifodbg(dev_priv);
+ }
+ 
+ static void __gen6_gt_force_wake_mt_put(struct drm_i915_private *dev_priv)
+ {
+ 	I915_WRITE_NOTRACE(FORCEWAKE_MT, _MASKED_BIT_DISABLE(1));
+-	/* gen6_gt_check_fifodbg doubles as the POSTING_READ */
++	/* something from same cacheline, but !FORCEWAKE_MT */
++	POSTING_READ(ECOBUS);
+ 	gen6_gt_check_fifodbg(dev_priv);
+ }
+ 
+@@ -4129,7 +4144,8 @@ static void vlv_force_wake_get(struct drm_i915_private *dev_priv)
+ static void vlv_force_wake_put(struct drm_i915_private *dev_priv)
+ {
+ 	I915_WRITE_NOTRACE(FORCEWAKE_VLV, _MASKED_BIT_DISABLE(1));
+-	/* The below doubles as a POSTING_READ */
++	/* something from same cacheline, but !FORCEWAKE_VLV */
++	POSTING_READ(FORCEWAKE_ACK_VLV);
+ 	gen6_gt_check_fifodbg(dev_priv);
+ }
+ 
+diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c
+index ecbc5c5..4b33f2d 100644
+--- a/drivers/gpu/drm/i915/intel_ringbuffer.c
++++ b/drivers/gpu/drm/i915/intel_ringbuffer.c
+@@ -505,13 +505,25 @@ static int init_render_ring(struct intel_ring_buffer *ring)
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	int ret = init_ring_common(ring);
+ 
+-	if (INTEL_INFO(dev)->gen > 3) {
++	if (INTEL_INFO(dev)->gen > 3)
+ 		I915_WRITE(MI_MODE, _MASKED_BIT_ENABLE(VS_TIMER_DISPATCH));
+-		if (IS_GEN7(dev))
+-			I915_WRITE(GFX_MODE_GEN7,
+-				   _MASKED_BIT_DISABLE(GFX_TLB_INVALIDATE_ALWAYS) |
+-				   _MASKED_BIT_ENABLE(GFX_REPLAY_MODE));
+-	}
++
++	/* We need to disable the AsyncFlip performance optimisations in order
++	 * to use MI_WAIT_FOR_EVENT within the CS. It should already be
++	 * programmed to '1' on all products.
++	 */
++	if (INTEL_INFO(dev)->gen >= 6)
++		I915_WRITE(MI_MODE, _MASKED_BIT_ENABLE(ASYNC_FLIP_PERF_DISABLE));
++
++	/* Required for the hardware to program scanline values for waiting */
++	if (INTEL_INFO(dev)->gen == 6)
++		I915_WRITE(GFX_MODE,
++			   _MASKED_BIT_ENABLE(GFX_TLB_INVALIDATE_ALWAYS));
++
++	if (IS_GEN7(dev))
++		I915_WRITE(GFX_MODE_GEN7,
++			   _MASKED_BIT_DISABLE(GFX_TLB_INVALIDATE_ALWAYS) |
++			   _MASKED_BIT_ENABLE(GFX_REPLAY_MODE));
+ 
+ 	if (INTEL_INFO(dev)->gen >= 5) {
+ 		ret = init_pipe_control(ring);
 diff --git a/drivers/gpu/drm/nouveau/core/include/subdev/bios/pll.h b/drivers/gpu/drm/nouveau/core/include/subdev/bios/pll.h
 index c345097..b2f3d4d 100644
 --- a/drivers/gpu/drm/nouveau/core/include/subdev/bios/pll.h
@@ -4211,10 +5047,10 @@
  			}
  		}
 diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c
-index 41672cc..dc8d15a 100644
+index 41672cc..e797080 100644
 --- a/drivers/gpu/drm/radeon/radeon_cs.c
 +++ b/drivers/gpu/drm/radeon/radeon_cs.c
-@@ -266,7 +266,7 @@ int radeon_cs_parser_init(struct radeon_cs_parser *p, void *data)
+@@ -266,13 +266,15 @@ int radeon_cs_parser_init(struct radeon_cs_parser *p, void *data)
  				  p->chunks[p->chunk_ib_idx].length_dw);
  			return -EINVAL;
  		}
@@ -4223,7 +5059,17 @@
  			p->chunks[p->chunk_ib_idx].kpage[0] = kmalloc(PAGE_SIZE, GFP_KERNEL);
  			p->chunks[p->chunk_ib_idx].kpage[1] = kmalloc(PAGE_SIZE, GFP_KERNEL);
  			if (p->chunks[p->chunk_ib_idx].kpage[0] == NULL ||
-@@ -570,7 +570,8 @@ static int radeon_cs_update_pages(struct radeon_cs_parser *p, int pg_idx)
+ 			    p->chunks[p->chunk_ib_idx].kpage[1] == NULL) {
+-				kfree(p->chunks[i].kpage[0]);
+-				kfree(p->chunks[i].kpage[1]);
++				kfree(p->chunks[p->chunk_ib_idx].kpage[0]);
++				kfree(p->chunks[p->chunk_ib_idx].kpage[1]);
++				p->chunks[p->chunk_ib_idx].kpage[0] = NULL;
++				p->chunks[p->chunk_ib_idx].kpage[1] = NULL;
+ 				return -ENOMEM;
+ 			}
+ 		}
+@@ -570,7 +572,8 @@ static int radeon_cs_update_pages(struct radeon_cs_parser *p, int pg_idx)
  	struct radeon_cs_chunk *ibc = &p->chunks[p->chunk_ib_idx];
  	int i;
  	int size = PAGE_SIZE;
@@ -4233,11 +5079,35 @@
  
  	for (i = ibc->last_copied_page + 1; i < pg_idx; i++) {
  		if (DRM_COPY_FROM_USER(p->ib.ptr + (i * (PAGE_SIZE/4)),
+diff --git a/drivers/gpu/drm/radeon/radeon_cursor.c b/drivers/gpu/drm/radeon/radeon_cursor.c
+index 0fe56c9..cd1f151 100644
+--- a/drivers/gpu/drm/radeon/radeon_cursor.c
++++ b/drivers/gpu/drm/radeon/radeon_cursor.c
+@@ -240,7 +240,8 @@ int radeon_crtc_cursor_move(struct drm_crtc *crtc,
+ 		y = 0;
+ 	}
+ 
+-	if (ASIC_IS_AVIVO(rdev)) {
++	/* fixed on DCE6 and newer */
++	if (ASIC_IS_AVIVO(rdev) && !ASIC_IS_DCE6(rdev)) {
+ 		int i = 0;
+ 		struct drm_crtc *crtc_p;
+ 
 diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c
-index e2f5f88..ad4c973 100644
+index e2f5f88..008d645 100644
 --- a/drivers/gpu/drm/radeon/radeon_device.c
 +++ b/drivers/gpu/drm/radeon/radeon_device.c
-@@ -1163,6 +1163,7 @@ int radeon_suspend_kms(struct drm_device *dev, pm_message_t state)
+@@ -429,7 +429,8 @@ bool radeon_card_posted(struct radeon_device *rdev)
+ {
+ 	uint32_t reg;
+ 
+-	if (efi_enabled && rdev->pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE)
++	if (efi_enabled(EFI_BOOT) &&
++	    rdev->pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE)
+ 		return false;
+ 
+ 	/* first check CRTCs */
+@@ -1163,6 +1164,7 @@ int radeon_suspend_kms(struct drm_device *dev, pm_message_t state)
  	struct drm_crtc *crtc;
  	struct drm_connector *connector;
  	int i, r;
@@ -4245,7 +5115,7 @@
  
  	if (dev == NULL || dev->dev_private == NULL) {
  		return -ENODEV;
-@@ -1205,8 +1206,16 @@ int radeon_suspend_kms(struct drm_device *dev, pm_message_t state)
+@@ -1205,8 +1207,16 @@ int radeon_suspend_kms(struct drm_device *dev, pm_message_t state)
  
  	mutex_lock(&rdev->ring_lock);
  	/* wait for gpu to finish processing current batch */
@@ -4264,7 +5134,7 @@
  	mutex_unlock(&rdev->ring_lock);
  
  	radeon_save_bios_scratch_regs(rdev);
-@@ -1337,7 +1346,6 @@ retry:
+@@ -1337,7 +1347,6 @@ retry:
  	}
  
  	radeon_restore_bios_scratch_regs(rdev);
@@ -4272,7 +5142,7 @@
  
  	if (!r) {
  		for (i = 0; i < RADEON_NUM_RINGS; ++i) {
-@@ -1357,11 +1365,14 @@ retry:
+@@ -1357,11 +1366,14 @@ retry:
  			}
  		}
  	} else {
@@ -4288,7 +5158,7 @@
  	if (r) {
  		/* bad news, how to tell it to userspace ? */
 diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
-index bfa2a60..2bddddd 100644
+index bfa2a60..6477849 100644
 --- a/drivers/gpu/drm/radeon/radeon_display.c
 +++ b/drivers/gpu/drm/radeon/radeon_display.c
 @@ -695,10 +695,15 @@ int radeon_ddc_get_modes(struct radeon_connector *radeon_connector)
@@ -4311,6 +5181,15 @@
  		struct radeon_connector_atom_dig *dig = radeon_connector->con_priv;
  
  		if ((dig->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT ||
+@@ -1113,7 +1118,7 @@ radeon_user_framebuffer_create(struct drm_device *dev,
+ 	if (ret) {
+ 		kfree(radeon_fb);
+ 		drm_gem_object_unreference_unlocked(obj);
+-		return NULL;
++		return ERR_PTR(ret);
+ 	}
+ 
+ 	return &radeon_fb->base;
 diff --git a/drivers/gpu/drm/radeon/radeon_fence.c b/drivers/gpu/drm/radeon/radeon_fence.c
 index 22bd6c2..28c09b6 100644
 --- a/drivers/gpu/drm/radeon/radeon_fence.c
@@ -4658,10 +5537,20 @@
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },
 diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
-index 9d7a428..1ef9a9e 100644
+index 9d7a428..7a845c0 100644
 --- a/drivers/hid/hid-ids.h
 +++ b/drivers/hid/hid-ids.h
-@@ -696,6 +696,9 @@
+@@ -305,6 +305,9 @@
+ #define USB_VENDOR_ID_EZKEY		0x0518
+ #define USB_DEVICE_ID_BTC_8193		0x0002
+ 
++#define USB_VENDOR_ID_FORMOSA          0x147a
++#define USB_DEVICE_ID_FORMOSA_IR_RECEIVER      0xe03e
++
+ #define USB_VENDOR_ID_FREESCALE		0x15A2
+ #define USB_DEVICE_ID_FREESCALE_MX28	0x004F
+ 
+@@ -696,6 +699,9 @@
  #define USB_VENDOR_ID_SIGMA_MICRO	0x1c4f
  #define USB_DEVICE_ID_SIGMA_MICRO_KEYBOARD	0x0002
  
@@ -4672,10 +5561,18 @@
  #define	USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER	0x3F07
  
 diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c
-index 11c7932..0a1429f 100644
+index 11c7932..29736e9 100644
 --- a/drivers/hid/usbhid/hid-quirks.c
 +++ b/drivers/hid/usbhid/hid-quirks.c
-@@ -79,6 +79,7 @@ static const struct hid_blacklist {
+@@ -70,6 +70,7 @@ static const struct hid_blacklist {
+ 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_AXIS_295, HID_QUIRK_NOGET },
+ 	{ USB_VENDOR_ID_DMI, USB_DEVICE_ID_DMI_ENC, HID_QUIRK_NOGET },
+ 	{ USB_VENDOR_ID_ELO, USB_DEVICE_ID_ELO_TS2700, HID_QUIRK_NOGET },
++	{ USB_VENDOR_ID_FORMOSA, USB_DEVICE_ID_FORMOSA_IR_RECEIVER, HID_QUIRK_NO_INIT_REPORTS },
+ 	{ USB_VENDOR_ID_FREESCALE, USB_DEVICE_ID_FREESCALE_MX28, HID_QUIRK_NOGET },
+ 	{ USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS, HID_QUIRK_NOGET },
+ 	{ USB_VENDOR_ID_PIXART, USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN, HID_QUIRK_NO_INIT_REPORTS },
+@@ -79,6 +80,7 @@ static const struct hid_blacklist {
  	{ USB_VENDOR_ID_QUANTA, USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3001, HID_QUIRK_NOGET },
  	{ USB_VENDOR_ID_QUANTA, USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3008, HID_QUIRK_NOGET },
  	{ USB_VENDOR_ID_SENNHEISER, USB_DEVICE_ID_SENNHEISER_BTD500USB, HID_QUIRK_NOGET },
@@ -5043,8 +5940,60 @@
  static const struct wacom_features wacom_features_0xD3 =
  	{ "Wacom Bamboo 2FG 6x8", WACOM_PKGLEN_BBFUN,     21648, 13700, 1023,
  	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
+diff --git a/drivers/iommu/amd_iommu_init.c b/drivers/iommu/amd_iommu_init.c
+index 81837b0..faf10ba 100644
+--- a/drivers/iommu/amd_iommu_init.c
++++ b/drivers/iommu/amd_iommu_init.c
+@@ -975,6 +975,38 @@ static void __init free_iommu_all(void)
+ }
+ 
+ /*
++ * Family15h Model 10h-1fh erratum 746 (IOMMU Logging May Stall Translations)
++ * Workaround:
++ *     BIOS should disable L2B micellaneous clock gating by setting
++ *     L2_L2B_CK_GATE_CONTROL[CKGateL2BMiscDisable](D0F2xF4_x90[2]) = 1b
++ */
++static void __init amd_iommu_erratum_746_workaround(struct amd_iommu *iommu)
++{
++	u32 value;
++
++	if ((boot_cpu_data.x86 != 0x15) ||
++	    (boot_cpu_data.x86_model < 0x10) ||
++	    (boot_cpu_data.x86_model > 0x1f))
++		return;
++
++	pci_write_config_dword(iommu->dev, 0xf0, 0x90);
++	pci_read_config_dword(iommu->dev, 0xf4, &value);
++
++	if (value & BIT(2))
++		return;
++
++	/* Select NB indirect register 0x90 and enable writing */
++	pci_write_config_dword(iommu->dev, 0xf0, 0x90 | (1 << 8));
++
++	pci_write_config_dword(iommu->dev, 0xf4, value | 0x4);
++	pr_info("AMD-Vi: Applying erratum 746 workaround for IOMMU at %s\n",
++		dev_name(&iommu->dev->dev));
++
++	/* Clear the enable writing bit */
++	pci_write_config_dword(iommu->dev, 0xf0, 0x90);
++}
++
++/*
+  * This function clues the initialization function for one IOMMU
+  * together and also allocates the command buffer and programs the
+  * hardware. It does NOT enable the IOMMU. This is done afterwards.
+@@ -1172,6 +1204,8 @@ static int iommu_init_pci(struct amd_iommu *iommu)
+ 			iommu->stored_l2[i] = iommu_read_l2(iommu, i);
+ 	}
+ 
++	amd_iommu_erratum_746_workaround(iommu);
++
+ 	return pci_enable_device(iommu->dev);
+ }
+ 
 diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
-index 0badfa4..c2c07a4 100644
+index 0badfa4..be3d7dd 100644
 --- a/drivers/iommu/intel-iommu.c
 +++ b/drivers/iommu/intel-iommu.c
 @@ -1827,10 +1827,17 @@ static int __domain_mapping(struct dmar_domain *domain, unsigned long iov_pfn,
@@ -5107,6 +6056,41 @@
  	if ((iommu_identity_mapping & IDENTMAP_AZALIA) && IS_AZALIA(pdev))
  		return 1;
  
+@@ -4196,6 +4234,21 @@ static struct iommu_ops intel_iommu_ops = {
+ 	.pgsize_bitmap	= INTEL_IOMMU_PGSIZES,
+ };
+ 
++static void __devinit quirk_iommu_g4x_gfx(struct pci_dev *dev)
++{
++	/* G4x/GM45 integrated gfx dmar support is totally busted. */
++	printk(KERN_INFO "DMAR: Disabling IOMMU for graphics on this chipset\n");
++	dmar_map_gfx = 0;
++}
++
++DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2a40, quirk_iommu_g4x_gfx);
++DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2e00, quirk_iommu_g4x_gfx);
++DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2e10, quirk_iommu_g4x_gfx);
++DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2e20, quirk_iommu_g4x_gfx);
++DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2e30, quirk_iommu_g4x_gfx);
++DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2e40, quirk_iommu_g4x_gfx);
++DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2e90, quirk_iommu_g4x_gfx);
++
+ static void __devinit quirk_iommu_rwbf(struct pci_dev *dev)
+ {
+ 	/*
+@@ -4204,12 +4257,6 @@ static void __devinit quirk_iommu_rwbf(struct pci_dev *dev)
+ 	 */
+ 	printk(KERN_INFO "DMAR: Forcing write-buffer flush capability\n");
+ 	rwbf_quirk = 1;
+-
+-	/* https://bugzilla.redhat.com/show_bug.cgi?id=538163 */
+-	if (dev->revision == 0x07) {
+-		printk(KERN_INFO "DMAR: Disabling IOMMU for graphics on this chipset\n");
+-		dmar_map_gfx = 0;
+-	}
+ }
+ 
+ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2a40, quirk_iommu_rwbf);
 diff --git a/drivers/md/dm-bio-prison.c b/drivers/md/dm-bio-prison.c
 index e4e8415..aefb78e 100644
 --- a/drivers/md/dm-bio-prison.c
@@ -5174,6 +6158,192 @@
  	/* Wipe the user buffer so we do not return it to userspace */
  	if (secure_data && clear_user(user, tmp.data_size))
  		goto bad;
+diff --git a/drivers/md/dm-raid.c b/drivers/md/dm-raid.c
+index 45d94a7..3235723 100644
+--- a/drivers/md/dm-raid.c
++++ b/drivers/md/dm-raid.c
+@@ -338,24 +338,22 @@ static int validate_region_size(struct raid_set *rs, unsigned long region_size)
+ }
+ 
+ /*
+- * validate_rebuild_devices
++ * validate_raid_redundancy
+  * @rs
+  *
+- * Determine if the devices specified for rebuild can result in a valid
+- * usable array that is capable of rebuilding the given devices.
++ * Determine if there are enough devices in the array that haven't
++ * failed (or are being rebuilt) to form a usable array.
+  *
+  * Returns: 0 on success, -EINVAL on failure.
+  */
+-static int validate_rebuild_devices(struct raid_set *rs)
++static int validate_raid_redundancy(struct raid_set *rs)
+ {
+ 	unsigned i, rebuild_cnt = 0;
+ 	unsigned rebuilds_per_group, copies, d;
+ 
+-	if (!(rs->print_flags & DMPF_REBUILD))
+-		return 0;
+-
+ 	for (i = 0; i < rs->md.raid_disks; i++)
+-		if (!test_bit(In_sync, &rs->dev[i].rdev.flags))
++		if (!test_bit(In_sync, &rs->dev[i].rdev.flags) ||
++		    !rs->dev[i].rdev.sb_page)
+ 			rebuild_cnt++;
+ 
+ 	switch (rs->raid_type->level) {
+@@ -391,27 +389,24 @@ static int validate_rebuild_devices(struct raid_set *rs)
+ 		 *          A    A    B    B    C
+ 		 *          C    D    D    E    E
+ 		 */
+-		rebuilds_per_group = 0;
+ 		for (i = 0; i < rs->md.raid_disks * copies; i++) {
++			if (!(i % copies))
++				rebuilds_per_group = 0;
+ 			d = i % rs->md.raid_disks;
+-			if (!test_bit(In_sync, &rs->dev[d].rdev.flags) &&
++			if ((!rs->dev[d].rdev.sb_page ||
++			     !test_bit(In_sync, &rs->dev[d].rdev.flags)) &&
+ 			    (++rebuilds_per_group >= copies))
+ 				goto too_many;
+-			if (!((i + 1) % copies))
+-				rebuilds_per_group = 0;
+ 		}
+ 		break;
+ 	default:
+-		DMERR("The rebuild parameter is not supported for %s",
+-		      rs->raid_type->name);
+-		rs->ti->error = "Rebuild not supported for this RAID type";
+-		return -EINVAL;
++		if (rebuild_cnt)
++			return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ 
+ too_many:
+-	rs->ti->error = "Too many rebuild devices specified";
+ 	return -EINVAL;
+ }
+ 
+@@ -662,9 +657,6 @@ static int parse_raid_params(struct raid_set *rs, char **argv,
+ 	}
+ 	rs->md.dev_sectors = sectors_per_dev;
+ 
+-	if (validate_rebuild_devices(rs))
+-		return -EINVAL;
+-
+ 	/* Assume there are no metadata devices until the drives are parsed */
+ 	rs->md.persistent = 0;
+ 	rs->md.external = 1;
+@@ -993,28 +985,10 @@ static int super_validate(struct mddev *mddev, struct md_rdev *rdev)
+ static int analyse_superblocks(struct dm_target *ti, struct raid_set *rs)
+ {
+ 	int ret;
+-	unsigned redundancy = 0;
+ 	struct raid_dev *dev;
+ 	struct md_rdev *rdev, *tmp, *freshest;
+ 	struct mddev *mddev = &rs->md;
+ 
+-	switch (rs->raid_type->level) {
+-	case 1:
+-		redundancy = rs->md.raid_disks - 1;
+-		break;
+-	case 4:
+-	case 5:
+-	case 6:
+-		redundancy = rs->raid_type->parity_devs;
+-		break;
+-	case 10:
+-		redundancy = raid10_md_layout_to_copies(mddev->layout) - 1;
+-		break;
+-	default:
+-		ti->error = "Unknown RAID type";
+-		return -EINVAL;
+-	}
+-
+ 	freshest = NULL;
+ 	rdev_for_each_safe(rdev, tmp, mddev) {
+ 		/*
+@@ -1043,44 +1017,43 @@ static int analyse_superblocks(struct dm_target *ti, struct raid_set *rs)
+ 			break;
+ 		default:
+ 			dev = container_of(rdev, struct raid_dev, rdev);
+-			if (redundancy--) {
+-				if (dev->meta_dev)
+-					dm_put_device(ti, dev->meta_dev);
+-
+-				dev->meta_dev = NULL;
+-				rdev->meta_bdev = NULL;
++			if (dev->meta_dev)
++				dm_put_device(ti, dev->meta_dev);
+ 
+-				if (rdev->sb_page)
+-					put_page(rdev->sb_page);
++			dev->meta_dev = NULL;
++			rdev->meta_bdev = NULL;
+ 
+-				rdev->sb_page = NULL;
++			if (rdev->sb_page)
++				put_page(rdev->sb_page);
+ 
+-				rdev->sb_loaded = 0;
++			rdev->sb_page = NULL;
+ 
+-				/*
+-				 * We might be able to salvage the data device
+-				 * even though the meta device has failed.  For
+-				 * now, we behave as though '- -' had been
+-				 * set for this device in the table.
+-				 */
+-				if (dev->data_dev)
+-					dm_put_device(ti, dev->data_dev);
++			rdev->sb_loaded = 0;
+ 
+-				dev->data_dev = NULL;
+-				rdev->bdev = NULL;
++			/*
++			 * We might be able to salvage the data device
++			 * even though the meta device has failed.  For
++			 * now, we behave as though '- -' had been
++			 * set for this device in the table.
++			 */
++			if (dev->data_dev)
++				dm_put_device(ti, dev->data_dev);
+ 
+-				list_del(&rdev->same_set);
++			dev->data_dev = NULL;
++			rdev->bdev = NULL;
+ 
+-				continue;
+-			}
+-			ti->error = "Failed to load superblock";
+-			return ret;
++			list_del(&rdev->same_set);
+ 		}
+ 	}
+ 
+ 	if (!freshest)
+ 		return 0;
+ 
++	if (validate_raid_redundancy(rs)) {
++		rs->ti->error = "Insufficient redundancy to activate array";
++		return -EINVAL;
++	}
++
+ 	/*
+ 	 * Validation of the freshest device provides the source of
+ 	 * validation for the remaining devices.
+@@ -1430,7 +1403,7 @@ static void raid_resume(struct dm_target *ti)
+ 
+ static struct target_type raid_target = {
+ 	.name = "raid",
+-	.version = {1, 3, 1},
++	.version = {1, 3, 2},
+ 	.module = THIS_MODULE,
+ 	.ctr = raid_ctr,
+ 	.dtr = raid_dtr,
 diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c
 index 100368e..fa29557 100644
 --- a/drivers/md/dm-table.c
@@ -5881,10 +7051,45 @@
  	/* find the base address of usage_count pointers (for freeing) */
  	if (!*usage_count || (cell->usage_count < *usage_count))
  		*usage_count = cell->usage_count;
-diff --git a/drivers/mfd/wm8994-core.c b/drivers/mfd/wm8994-core.c
-index 8fefc96..f1ac288 100644
---- a/drivers/mfd/wm8994-core.c
-+++ b/drivers/mfd/wm8994-core.c
+diff --git a/drivers/mfd/tc3589x.c b/drivers/mfd/tc3589x.c
+index 8f4c853..4678156 100644
+--- a/drivers/mfd/tc3589x.c
++++ b/drivers/mfd/tc3589x.c
+@@ -219,25 +219,18 @@ static void tc3589x_irq_unmap(struct irq_domain *d, unsigned int virq)
+ }
+ 
+ static struct irq_domain_ops tc3589x_irq_ops = {
+-        .map    = tc3589x_irq_map,
++	.map    = tc3589x_irq_map,
+ 	.unmap  = tc3589x_irq_unmap,
+-        .xlate  = irq_domain_xlate_twocell,
++	.xlate  = irq_domain_xlate_twocell,
+ };
+ 
+ static int tc3589x_irq_init(struct tc3589x *tc3589x, struct device_node *np)
+ {
+ 	int base = tc3589x->irq_base;
+ 
+-	if (base) {
+-		tc3589x->domain = irq_domain_add_legacy(
+-			NULL, TC3589x_NR_INTERNAL_IRQS, base,
+-			0, &tc3589x_irq_ops, tc3589x);
+-	}
+-	else {
+-		tc3589x->domain = irq_domain_add_linear(
+-			np, TC3589x_NR_INTERNAL_IRQS,
+-			&tc3589x_irq_ops, tc3589x);
+-	}
++	tc3589x->domain = irq_domain_add_simple(
++		np, TC3589x_NR_INTERNAL_IRQS, base,
++		&tc3589x_irq_ops, tc3589x);
+ 
+ 	if (!tc3589x->domain) {
+ 		dev_err(tc3589x->dev, "Failed to create irqdomain\n");
+diff --git a/drivers/mfd/wm8994-core.c b/drivers/mfd/wm8994-core.c
+index 8fefc96..f1ac288 100644
+--- a/drivers/mfd/wm8994-core.c
++++ b/drivers/mfd/wm8994-core.c
 @@ -557,6 +557,7 @@ static __devinit int wm8994_device_init(struct wm8994 *wm8994, int irq)
  		case 1:
  		case 2:
@@ -6087,6 +7292,28 @@
  	/* Choose NAND mode. */
  	writel(BM_GPMI_CTRL1_GPMI_MODE, r->gpmi_regs + HW_GPMI_CTRL1_CLR);
  
+diff --git a/drivers/net/can/c_can/c_can.c b/drivers/net/can/c_can/c_can.c
+index e5180df..3391bdd 100644
+--- a/drivers/net/can/c_can/c_can.c
++++ b/drivers/net/can/c_can/c_can.c
+@@ -954,7 +954,7 @@ static int c_can_handle_bus_err(struct net_device *dev,
+ 		break;
+ 	case LEC_ACK_ERROR:
+ 		netdev_dbg(dev, "ack error\n");
+-		cf->data[2] |= (CAN_ERR_PROT_LOC_ACK |
++		cf->data[3] |= (CAN_ERR_PROT_LOC_ACK |
+ 				CAN_ERR_PROT_LOC_ACK_DEL);
+ 		break;
+ 	case LEC_BIT1_ERROR:
+@@ -967,7 +967,7 @@ static int c_can_handle_bus_err(struct net_device *dev,
+ 		break;
+ 	case LEC_CRC_ERROR:
+ 		netdev_dbg(dev, "CRC error\n");
+-		cf->data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
++		cf->data[3] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
+ 				CAN_ERR_PROT_LOC_CRC_DEL);
+ 		break;
+ 	default:
 diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
 index 963e2cc..8233e5e 100644
 --- a/drivers/net/can/dev.c
@@ -6101,6 +7328,38 @@
  	can_flush_echo_skb(dev);
  }
  EXPORT_SYMBOL_GPL(close_candev);
+diff --git a/drivers/net/can/pch_can.c b/drivers/net/can/pch_can.c
+index 48b3d62..7a43d4d 100644
+--- a/drivers/net/can/pch_can.c
++++ b/drivers/net/can/pch_can.c
+@@ -560,7 +560,7 @@ static void pch_can_error(struct net_device *ndev, u32 status)
+ 		stats->rx_errors++;
+ 		break;
+ 	case PCH_CRC_ERR:
+-		cf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
++		cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ |
+ 			       CAN_ERR_PROT_LOC_CRC_DEL;
+ 		priv->can.can_stats.bus_error++;
+ 		stats->rx_errors++;
+diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c
+index 9ded21e..44996a9 100644
+--- a/drivers/net/can/ti_hecc.c
++++ b/drivers/net/can/ti_hecc.c
+@@ -746,12 +746,12 @@ static int ti_hecc_error(struct net_device *ndev, int int_status,
+ 		}
+ 		if (err_status & HECC_CANES_CRCE) {
+ 			hecc_set_bit(priv, HECC_CANES, HECC_CANES_CRCE);
+-			cf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
++			cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ |
+ 					CAN_ERR_PROT_LOC_CRC_DEL;
+ 		}
+ 		if (err_status & HECC_CANES_ACKE) {
+ 			hecc_set_bit(priv, HECC_CANES, HECC_CANES_ACKE);
+-			cf->data[2] |= CAN_ERR_PROT_LOC_ACK |
++			cf->data[3] |= CAN_ERR_PROT_LOC_ACK |
+ 					CAN_ERR_PROT_LOC_ACK_DEL;
+ 		}
+ 	}
 diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
 index e1ceb37..9b178a3 100644
 --- a/drivers/net/ethernet/intel/igb/igb_main.c
@@ -6609,6 +7868,95 @@
  	else if (AR_SREV_9550(ah)) {
  		INIT_INI_ARRAY(&ah->iniModesRxGain,
  				ar955x_1p0_common_rx_gain_table);
+diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.c b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+index 759f5f5..8a38ff2 100644
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+@@ -588,30 +588,17 @@ static void ar9003_hw_init_bb(struct ath_hw *ah,
+ 
+ static void ar9003_hw_set_chain_masks(struct ath_hw *ah, u8 rx, u8 tx)
+ {
+-	switch (rx) {
+-	case 0x5:
++	if (ah->caps.tx_chainmask == 5 || ah->caps.rx_chainmask == 5)
+ 		REG_SET_BIT(ah, AR_PHY_ANALOG_SWAP,
+ 			    AR_PHY_SWAP_ALT_CHAIN);
+-	case 0x3:
+-	case 0x1:
+-	case 0x2:
+-	case 0x7:
+-		REG_WRITE(ah, AR_PHY_RX_CHAINMASK, rx);
+-		REG_WRITE(ah, AR_PHY_CAL_CHAINMASK, rx);
+-		break;
+-	default:
+-		break;
+-	}
++
++	REG_WRITE(ah, AR_PHY_RX_CHAINMASK, rx);
++	REG_WRITE(ah, AR_PHY_CAL_CHAINMASK, rx);
+ 
+ 	if ((ah->caps.hw_caps & ATH9K_HW_CAP_APM) && (tx == 0x7))
+-		REG_WRITE(ah, AR_SELFGEN_MASK, 0x3);
+-	else
+-		REG_WRITE(ah, AR_SELFGEN_MASK, tx);
++		tx = 3;
+ 
+-	if (tx == 0x5) {
+-		REG_SET_BIT(ah, AR_PHY_ANALOG_SWAP,
+-			    AR_PHY_SWAP_ALT_CHAIN);
+-	}
++	REG_WRITE(ah, AR_SELFGEN_MASK, tx);
+ }
+ 
+ /*
+diff --git a/drivers/net/wireless/ath/ath9k/ath9k.h b/drivers/net/wireless/ath/ath9k/ath9k.h
+index dfe6a47..d7897dcf 100644
+--- a/drivers/net/wireless/ath/ath9k/ath9k.h
++++ b/drivers/net/wireless/ath/ath9k/ath9k.h
+@@ -315,7 +315,6 @@ struct ath_rx {
+ 	u32 *rxlink;
+ 	u32 num_pkts;
+ 	unsigned int rxfilter;
+-	spinlock_t rxbuflock;
+ 	struct list_head rxbuf;
+ 	struct ath_descdma rxdma;
+ 	struct ath_buf *rx_bufptr;
+@@ -326,7 +325,6 @@ struct ath_rx {
+ 
+ int ath_startrecv(struct ath_softc *sc);
+ bool ath_stoprecv(struct ath_softc *sc);
+-void ath_flushrecv(struct ath_softc *sc);
+ u32 ath_calcrxfilter(struct ath_softc *sc);
+ int ath_rx_init(struct ath_softc *sc, int nbufs);
+ void ath_rx_cleanup(struct ath_softc *sc);
+@@ -630,7 +628,6 @@ void ath_ant_comb_update(struct ath_softc *sc);
+ enum sc_op_flags {
+ 	SC_OP_INVALID,
+ 	SC_OP_BEACONS,
+-	SC_OP_RXFLUSH,
+ 	SC_OP_ANI_RUN,
+ 	SC_OP_PRIM_STA_VIF,
+ 	SC_OP_HW_RESET,
+diff --git a/drivers/net/wireless/ath/ath9k/beacon.c b/drivers/net/wireless/ath/ath9k/beacon.c
+index 1b48414..4b2dabf 100644
+--- a/drivers/net/wireless/ath/ath9k/beacon.c
++++ b/drivers/net/wireless/ath/ath9k/beacon.c
+@@ -147,6 +147,7 @@ static struct ath_buf *ath9k_beacon_generate(struct ieee80211_hw *hw,
+ 				 skb->len, DMA_TO_DEVICE);
+ 		dev_kfree_skb_any(skb);
+ 		bf->bf_buf_addr = 0;
++		bf->bf_mpdu = NULL;
+ 	}
+ 
+ 	skb = ieee80211_beacon_get(hw, vif);
+@@ -359,7 +360,6 @@ void ath9k_beacon_tasklet(unsigned long data)
+ 		return;
+ 
+ 	bf = ath9k_beacon_generate(sc->hw, vif);
+-	WARN_ON(!bf);
+ 
+ 	if (sc->beacon.bmisscnt != 0) {
+ 		ath_dbg(common, BSTUCK, "resume beacon xmit after %u misses\n",
 diff --git a/drivers/net/wireless/ath/ath9k/calib.c b/drivers/net/wireless/ath/ath9k/calib.c
 index e5cceb0..bbd249d 100644
 --- a/drivers/net/wireless/ath/ath9k/calib.c
@@ -6635,6 +7983,290 @@
  #define NUM_NF_READINGS       6
  #define ATH9K_NF_CAL_HIST_MAX 5
  
+diff --git a/drivers/net/wireless/ath/ath9k/debug.c b/drivers/net/wireless/ath/ath9k/debug.c
+index 6727b56..774e95b 100644
+--- a/drivers/net/wireless/ath/ath9k/debug.c
++++ b/drivers/net/wireless/ath/ath9k/debug.c
+@@ -973,7 +973,6 @@ static ssize_t read_file_recv(struct file *file, char __user *user_buf,
+ 	RXS_ERR("RX-LENGTH-ERR", rx_len_err);
+ 	RXS_ERR("RX-OOM-ERR", rx_oom_err);
+ 	RXS_ERR("RX-RATE-ERR", rx_rate_err);
+-	RXS_ERR("RX-DROP-RXFLUSH", rx_drop_rxflush);
+ 	RXS_ERR("RX-TOO-MANY-FRAGS", rx_too_many_frags_err);
+ 
+ 	PHY_ERR("UNDERRUN ERR", ATH9K_PHYERR_UNDERRUN);
+diff --git a/drivers/net/wireless/ath/ath9k/debug.h b/drivers/net/wireless/ath/ath9k/debug.h
+index 2ed9785..b9d95c7 100644
+--- a/drivers/net/wireless/ath/ath9k/debug.h
++++ b/drivers/net/wireless/ath/ath9k/debug.h
+@@ -200,7 +200,6 @@ struct ath_tx_stats {
+  * @rx_oom_err:  No. of frames dropped due to OOM issues.
+  * @rx_rate_err:  No. of frames dropped due to rate errors.
+  * @rx_too_many_frags_err:  Frames dropped due to too-many-frags received.
+- * @rx_drop_rxflush: No. of frames dropped due to RX-FLUSH.
+  * @rx_beacons:  No. of beacons received.
+  * @rx_frags:  No. of rx-fragements received.
+  */
+@@ -219,7 +218,6 @@ struct ath_rx_stats {
+ 	u32 rx_oom_err;
+ 	u32 rx_rate_err;
+ 	u32 rx_too_many_frags_err;
+-	u32 rx_drop_rxflush;
+ 	u32 rx_beacons;
+ 	u32 rx_frags;
+ };
+diff --git a/drivers/net/wireless/ath/ath9k/htc_hst.c b/drivers/net/wireless/ath/ath9k/htc_hst.c
+index 4a9570d..aac4a40 100644
+--- a/drivers/net/wireless/ath/ath9k/htc_hst.c
++++ b/drivers/net/wireless/ath/ath9k/htc_hst.c
+@@ -344,6 +344,8 @@ void ath9k_htc_txcompletion_cb(struct htc_target *htc_handle,
+ 			endpoint->ep_callbacks.tx(endpoint->ep_callbacks.priv,
+ 						  skb, htc_hdr->endpoint_id,
+ 						  txok);
++		} else {
++			kfree_skb(skb);
+ 		}
+ 	}
+ 
+diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c
+index dd45edf..6962c8a 100644
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -181,7 +181,7 @@ static void ath_restart_work(struct ath_softc *sc)
+ 	ath_start_ani(sc);
+ }
+ 
+-static bool ath_prepare_reset(struct ath_softc *sc, bool retry_tx, bool flush)
++static bool ath_prepare_reset(struct ath_softc *sc, bool retry_tx)
+ {
+ 	struct ath_hw *ah = sc->sc_ah;
+ 	bool ret = true;
+@@ -201,14 +201,6 @@ static bool ath_prepare_reset(struct ath_softc *sc, bool retry_tx, bool flush)
+ 	if (!ath_drain_all_txq(sc, retry_tx))
+ 		ret = false;
+ 
+-	if (!flush) {
+-		if (ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)
+-			ath_rx_tasklet(sc, 1, true);
+-		ath_rx_tasklet(sc, 1, false);
+-	} else {
+-		ath_flushrecv(sc);
+-	}
+-
+ 	return ret;
+ }
+ 
+@@ -261,11 +253,11 @@ static int ath_reset_internal(struct ath_softc *sc, struct ath9k_channel *hchan,
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 	struct ath9k_hw_cal_data *caldata = NULL;
+ 	bool fastcc = true;
+-	bool flush = false;
+ 	int r;
+ 
+ 	__ath_cancel_work(sc);
+ 
++	tasklet_disable(&sc->intr_tq);
+ 	spin_lock_bh(&sc->sc_pcu_lock);
+ 
+ 	if (!(sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)) {
+@@ -275,11 +267,10 @@ static int ath_reset_internal(struct ath_softc *sc, struct ath9k_channel *hchan,
+ 
+ 	if (!hchan) {
+ 		fastcc = false;
+-		flush = true;
+ 		hchan = ah->curchan;
+ 	}
+ 
+-	if (!ath_prepare_reset(sc, retry_tx, flush))
++	if (!ath_prepare_reset(sc, retry_tx))
+ 		fastcc = false;
+ 
+ 	ath_dbg(common, CONFIG, "Reset to %u MHz, HT40: %d fastcc: %d\n",
+@@ -297,6 +288,8 @@ static int ath_reset_internal(struct ath_softc *sc, struct ath9k_channel *hchan,
+ 
+ out:
+ 	spin_unlock_bh(&sc->sc_pcu_lock);
++	tasklet_enable(&sc->intr_tq);
++
+ 	return r;
+ }
+ 
+@@ -816,7 +809,7 @@ static void ath9k_stop(struct ieee80211_hw *hw)
+ 		ath9k_hw_cfg_gpio_input(ah, ah->led_pin);
+ 	}
+ 
+-	ath_prepare_reset(sc, false, true);
++	ath_prepare_reset(sc, false);
+ 
+ 	if (sc->rx.frag) {
+ 		dev_kfree_skb_any(sc->rx.frag);
+@@ -1837,6 +1830,9 @@ static u32 fill_chainmask(u32 cap, u32 new)
+ 
+ static bool validate_antenna_mask(struct ath_hw *ah, u32 val)
+ {
++	if (AR_SREV_9300_20_OR_LATER(ah))
++		return true;
++
+ 	switch (val & 0x7) {
+ 	case 0x1:
+ 	case 0x3:
+diff --git a/drivers/net/wireless/ath/ath9k/recv.c b/drivers/net/wireless/ath/ath9k/recv.c
+index 83d16e7..4919d68 100644
+--- a/drivers/net/wireless/ath/ath9k/recv.c
++++ b/drivers/net/wireless/ath/ath9k/recv.c
+@@ -254,8 +254,6 @@ rx_init_fail:
+ 
+ static void ath_edma_start_recv(struct ath_softc *sc)
+ {
+-	spin_lock_bh(&sc->rx.rxbuflock);
+-
+ 	ath9k_hw_rxena(sc->sc_ah);
+ 
+ 	ath_rx_addbuffer_edma(sc, ATH9K_RX_QUEUE_HP,
+@@ -267,8 +265,6 @@ static void ath_edma_start_recv(struct ath_softc *sc)
+ 	ath_opmode_init(sc);
+ 
+ 	ath9k_hw_startpcureceive(sc->sc_ah, !!(sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL));
+-
+-	spin_unlock_bh(&sc->rx.rxbuflock);
+ }
+ 
+ static void ath_edma_stop_recv(struct ath_softc *sc)
+@@ -285,8 +281,6 @@ int ath_rx_init(struct ath_softc *sc, int nbufs)
+ 	int error = 0;
+ 
+ 	spin_lock_init(&sc->sc_pcu_lock);
+-	spin_lock_init(&sc->rx.rxbuflock);
+-	clear_bit(SC_OP_RXFLUSH, &sc->sc_flags);
+ 
+ 	common->rx_bufsize = IEEE80211_MAX_MPDU_LEN / 2 +
+ 			     sc->sc_ah->caps.rx_status_len;
+@@ -447,7 +441,6 @@ int ath_startrecv(struct ath_softc *sc)
+ 		return 0;
+ 	}
+ 
+-	spin_lock_bh(&sc->rx.rxbuflock);
+ 	if (list_empty(&sc->rx.rxbuf))
+ 		goto start_recv;
+ 
+@@ -468,26 +461,31 @@ start_recv:
+ 	ath_opmode_init(sc);
+ 	ath9k_hw_startpcureceive(ah, !!(sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL));
+ 
+-	spin_unlock_bh(&sc->rx.rxbuflock);
+-
+ 	return 0;
+ }
+ 
++static void ath_flushrecv(struct ath_softc *sc)
++{
++	if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)
++		ath_rx_tasklet(sc, 1, true);
++	ath_rx_tasklet(sc, 1, false);
++}
++
+ bool ath_stoprecv(struct ath_softc *sc)
+ {
+ 	struct ath_hw *ah = sc->sc_ah;
+ 	bool stopped, reset = false;
+ 
+-	spin_lock_bh(&sc->rx.rxbuflock);
+ 	ath9k_hw_abortpcurecv(ah);
+ 	ath9k_hw_setrxfilter(ah, 0);
+ 	stopped = ath9k_hw_stopdmarecv(ah, &reset);
+ 
++	ath_flushrecv(sc);
++
+ 	if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)
+ 		ath_edma_stop_recv(sc);
+ 	else
+ 		sc->rx.rxlink = NULL;
+-	spin_unlock_bh(&sc->rx.rxbuflock);
+ 
+ 	if (!(ah->ah_flags & AH_UNPLUGGED) &&
+ 	    unlikely(!stopped)) {
+@@ -499,15 +497,6 @@ bool ath_stoprecv(struct ath_softc *sc)
+ 	return stopped && !reset;
+ }
+ 
+-void ath_flushrecv(struct ath_softc *sc)
+-{
+-	set_bit(SC_OP_RXFLUSH, &sc->sc_flags);
+-	if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)
+-		ath_rx_tasklet(sc, 1, true);
+-	ath_rx_tasklet(sc, 1, false);
+-	clear_bit(SC_OP_RXFLUSH, &sc->sc_flags);
+-}
+-
+ static bool ath_beacon_dtim_pending_cab(struct sk_buff *skb)
+ {
+ 	/* Check whether the Beacon frame has DTIM indicating buffered bc/mc */
+@@ -744,6 +733,7 @@ static struct ath_buf *ath_get_next_rx_buf(struct ath_softc *sc,
+ 			return NULL;
+ 	}
+ 
++	list_del(&bf->list);
+ 	if (!bf->bf_mpdu)
+ 		return bf;
+ 
+@@ -1059,16 +1049,12 @@ int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
+ 		dma_type = DMA_FROM_DEVICE;
+ 
+ 	qtype = hp ? ATH9K_RX_QUEUE_HP : ATH9K_RX_QUEUE_LP;
+-	spin_lock_bh(&sc->rx.rxbuflock);
+ 
+ 	tsf = ath9k_hw_gettsf64(ah);
+ 	tsf_lower = tsf & 0xffffffff;
+ 
+ 	do {
+ 		bool decrypt_error = false;
+-		/* If handling rx interrupt and flush is in progress => exit */
+-		if (test_bit(SC_OP_RXFLUSH, &sc->sc_flags) && (flush == 0))
+-			break;
+ 
+ 		memset(&rs, 0, sizeof(rs));
+ 		if (edma)
+@@ -1108,15 +1094,6 @@ int ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp)
+ 		sc->rx.num_pkts++;
+ 		ath_debug_stat_rx(sc, &rs);
+ 
+-		/*
+-		 * If we're asked to flush receive queue, directly
+-		 * chain it back at the queue without processing it.
+-		 */
+-		if (test_bit(SC_OP_RXFLUSH, &sc->sc_flags)) {
+-			RX_STAT_INC(rx_drop_rxflush);
+-			goto requeue_drop_frag;
+-		}
+-
+ 		memset(rxs, 0, sizeof(struct ieee80211_rx_status));
+ 
+ 		rxs->mactime = (tsf & ~0xffffffffULL) | rs.rs_tstamp;
+@@ -1251,19 +1228,18 @@ requeue_drop_frag:
+ 			sc->rx.frag = NULL;
+ 		}
+ requeue:
++		list_add_tail(&bf->list, &sc->rx.rxbuf);
++		if (flush)
++			continue;
++
+ 		if (edma) {
+-			list_add_tail(&bf->list, &sc->rx.rxbuf);
+ 			ath_rx_edma_buf_link(sc, qtype);
+ 		} else {
+-			list_move_tail(&bf->list, &sc->rx.rxbuf);
+ 			ath_rx_buf_link(sc, bf);
+-			if (!flush)
+-				ath9k_hw_rxena(ah);
++			ath9k_hw_rxena(ah);
+ 		}
+ 	} while (1);
+ 
+-	spin_unlock_bh(&sc->rx.rxbuflock);
+-
+ 	if (!(ah->imask & ATH9K_INT_RXEOL)) {
+ 		ah->imask |= (ATH9K_INT_RXEOL | ATH9K_INT_RXORN);
+ 		ath9k_hw_set_interrupts(ah);
 diff --git a/drivers/net/wireless/ath/carl9170/fw.c b/drivers/net/wireless/ath/carl9170/fw.c
 index 24ac287..98f4010 100644
 --- a/drivers/net/wireless/ath/carl9170/fw.c
@@ -7030,6 +8662,192 @@
  
  	/* check for multicast cipher suite */
  	if (offset + WPA_IE_MIN_OUI_LEN > len) {
+diff --git a/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c b/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+index a744ea5..36014bf 100644
+--- a/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+@@ -280,8 +280,8 @@ static void brcms_ops_tx(struct ieee80211_hw *hw,
+ 		kfree_skb(skb);
+ 		goto done;
+ 	}
+-	brcms_c_sendpkt_mac80211(wl->wlc, skb, hw);
+-	tx_info->rate_driver_data[0] = control->sta;
++	if (brcms_c_sendpkt_mac80211(wl->wlc, skb, hw))
++		tx_info->rate_driver_data[0] = control->sta;
+  done:
+ 	spin_unlock_bh(&wl->lock);
+ }
+@@ -1401,9 +1401,10 @@ void brcms_add_timer(struct brcms_timer *t, uint ms, int periodic)
+ #endif
+ 	t->ms = ms;
+ 	t->periodic = (bool) periodic;
+-	t->set = true;
+-
+-	atomic_inc(&t->wl->callbacks);
++	if (!t->set) {
++		t->set = true;
++		atomic_inc(&t->wl->callbacks);
++	}
+ 
+ 	ieee80211_queue_delayed_work(hw, &t->dly_wrk, msecs_to_jiffies(ms));
+ }
+diff --git a/drivers/net/wireless/brcm80211/brcmsmac/main.c b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+index 75086b3..9fb0a4c9 100644
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+@@ -6095,7 +6095,7 @@ static bool brcms_c_prec_enq(struct brcms_c_info *wlc, struct pktq *q,
+ 	return brcms_c_prec_enq_head(wlc, q, pkt, prec, false);
+ }
+ 
+-void brcms_c_txq_enq(struct brcms_c_info *wlc, struct scb *scb,
++bool brcms_c_txq_enq(struct brcms_c_info *wlc, struct scb *scb,
+ 		     struct sk_buff *sdu, uint prec)
+ {
+ 	struct brcms_txq_info *qi = wlc->pkt_queue;	/* Check me */
+@@ -6110,7 +6110,9 @@ void brcms_c_txq_enq(struct brcms_c_info *wlc, struct scb *scb,
+ 		 * packet flooding from mac80211 stack
+ 		 */
+ 		brcmu_pkt_buf_free_skb(sdu);
++		return false;
+ 	}
++	return true;
+ }
+ 
+ /*
+@@ -7273,7 +7275,7 @@ brcms_c_d11hdrs_mac80211(struct brcms_c_info *wlc, struct ieee80211_hw *hw,
+ 	return 0;
+ }
+ 
+-void brcms_c_sendpkt_mac80211(struct brcms_c_info *wlc, struct sk_buff *sdu,
++bool brcms_c_sendpkt_mac80211(struct brcms_c_info *wlc, struct sk_buff *sdu,
+ 			      struct ieee80211_hw *hw)
+ {
+ 	u8 prio;
+@@ -7288,10 +7290,12 @@ void brcms_c_sendpkt_mac80211(struct brcms_c_info *wlc, struct sk_buff *sdu,
+ 	prio = ieee80211_is_data(d11_header->frame_control) ? sdu->priority :
+ 		MAXPRIO;
+ 	fifo = prio2fifo[prio];
+-	if (brcms_c_d11hdrs_mac80211(wlc, hw, sdu, scb, 0, 1, fifo, 0))
+-		return;
+-	brcms_c_txq_enq(wlc, scb, sdu, BRCMS_PRIO_TO_PREC(prio));
++	brcms_c_d11hdrs_mac80211(wlc, hw, sdu, scb, 0, 1, fifo, 0);
++	if (!brcms_c_txq_enq(wlc, scb, sdu, BRCMS_PRIO_TO_PREC(prio)))
++		return false;
+ 	brcms_c_send_q(wlc);
++
++	return true;
+ }
+ 
+ void brcms_c_send_q(struct brcms_c_info *wlc)
+diff --git a/drivers/net/wireless/brcm80211/brcmsmac/main.h b/drivers/net/wireless/brcm80211/brcmsmac/main.h
+index 8debc74..b44725c 100644
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.h
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.h
+@@ -642,7 +642,7 @@ extern void brcms_c_txfifo(struct brcms_c_info *wlc, uint fifo,
+ 			   bool commit, s8 txpktpend);
+ extern void brcms_c_txfifo_complete(struct brcms_c_info *wlc, uint fifo,
+ 				    s8 txpktpend);
+-extern void brcms_c_txq_enq(struct brcms_c_info *wlc, struct scb *scb,
++extern bool brcms_c_txq_enq(struct brcms_c_info *wlc, struct scb *scb,
+ 			    struct sk_buff *sdu, uint prec);
+ extern void brcms_c_print_txstatus(struct tx_status *txs);
+ extern int brcms_b_xmtfifo_sz_get(struct brcms_hardware *wlc_hw, uint fifo,
+diff --git a/drivers/net/wireless/brcm80211/brcmsmac/pub.h b/drivers/net/wireless/brcm80211/brcmsmac/pub.h
+index 5855f4f..bfa2630 100644
+--- a/drivers/net/wireless/brcm80211/brcmsmac/pub.h
++++ b/drivers/net/wireless/brcm80211/brcmsmac/pub.h
+@@ -321,7 +321,7 @@ extern void brcms_c_intrsrestore(struct brcms_c_info *wlc, u32 macintmask);
+ extern bool brcms_c_intrsupd(struct brcms_c_info *wlc);
+ extern bool brcms_c_isr(struct brcms_c_info *wlc, bool *wantdpc);
+ extern bool brcms_c_dpc(struct brcms_c_info *wlc, bool bounded);
+-extern void brcms_c_sendpkt_mac80211(struct brcms_c_info *wlc,
++extern bool brcms_c_sendpkt_mac80211(struct brcms_c_info *wlc,
+ 				     struct sk_buff *sdu,
+ 				     struct ieee80211_hw *hw);
+ extern bool brcms_c_aggregatable(struct brcms_c_info *wlc, u8 tid);
+diff --git a/drivers/net/wireless/iwlegacy/common.c b/drivers/net/wireless/iwlegacy/common.c
+index 318ed3c..617aeb9 100644
+--- a/drivers/net/wireless/iwlegacy/common.c
++++ b/drivers/net/wireless/iwlegacy/common.c
+@@ -3957,17 +3957,21 @@ il_connection_init_rx_config(struct il_priv *il)
+ 
+ 	memset(&il->staging, 0, sizeof(il->staging));
+ 
+-	if (!il->vif) {
++	switch (il->iw_mode) {
++	case NL80211_IFTYPE_UNSPECIFIED:
+ 		il->staging.dev_type = RXON_DEV_TYPE_ESS;
+-	} else if (il->vif->type == NL80211_IFTYPE_STATION) {
++		break;
++	case NL80211_IFTYPE_STATION:
+ 		il->staging.dev_type = RXON_DEV_TYPE_ESS;
+ 		il->staging.filter_flags = RXON_FILTER_ACCEPT_GRP_MSK;
+-	} else if (il->vif->type == NL80211_IFTYPE_ADHOC) {
++		break;
++	case NL80211_IFTYPE_ADHOC:
+ 		il->staging.dev_type = RXON_DEV_TYPE_IBSS;
+ 		il->staging.flags = RXON_FLG_SHORT_PREAMBLE_MSK;
+ 		il->staging.filter_flags =
+ 		    RXON_FILTER_BCON_AWARE_MSK | RXON_FILTER_ACCEPT_GRP_MSK;
+-	} else {
++		break;
++	default:
+ 		IL_ERR("Unsupported interface type %d\n", il->vif->type);
+ 		return;
+ 	}
+@@ -4550,8 +4554,7 @@ out:
+ EXPORT_SYMBOL(il_mac_add_interface);
+ 
+ static void
+-il_teardown_interface(struct il_priv *il, struct ieee80211_vif *vif,
+-		      bool mode_change)
++il_teardown_interface(struct il_priv *il, struct ieee80211_vif *vif)
+ {
+ 	lockdep_assert_held(&il->mutex);
+ 
+@@ -4560,9 +4563,7 @@ il_teardown_interface(struct il_priv *il, struct ieee80211_vif *vif,
+ 		il_force_scan_end(il);
+ 	}
+ 
+-	if (!mode_change)
+-		il_set_mode(il);
+-
++	il_set_mode(il);
+ }
+ 
+ void
+@@ -4575,8 +4576,8 @@ il_mac_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+ 
+ 	WARN_ON(il->vif != vif);
+ 	il->vif = NULL;
+-
+-	il_teardown_interface(il, vif, false);
++	il->iw_mode = NL80211_IFTYPE_UNSPECIFIED;
++	il_teardown_interface(il, vif);
+ 	memset(il->bssid, 0, ETH_ALEN);
+ 
+ 	D_MAC80211("leave\n");
+@@ -4685,18 +4686,10 @@ il_mac_change_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+ 	}
+ 
+ 	/* success */
+-	il_teardown_interface(il, vif, true);
+ 	vif->type = newtype;
+ 	vif->p2p = false;
+-	err = il_set_mode(il);
+-	WARN_ON(err);
+-	/*
+-	 * We've switched internally, but submitting to the
+-	 * device may have failed for some reason. Mask this
+-	 * error, because otherwise mac80211 will not switch
+-	 * (and set the interface type back) and we'll be
+-	 * out of sync with it.
+-	 */
++	il->iw_mode = newtype;
++	il_teardown_interface(il, vif);
+ 	err = 0;
+ 
+ out:
 diff --git a/drivers/net/wireless/iwlwifi/dvm/tx.c b/drivers/net/wireless/iwlwifi/dvm/tx.c
 index f5ca73a..aecf1ce 100644
 --- a/drivers/net/wireless/iwlwifi/dvm/tx.c
@@ -7187,8 +9005,54 @@
  	iwl_write32(trans, CSR_INT_MASK, 0x00000000);
  
  
+diff --git a/drivers/net/wireless/mwifiex/cfg80211.c b/drivers/net/wireless/mwifiex/cfg80211.c
+index 780d3e1..f7e91f2 100644
+--- a/drivers/net/wireless/mwifiex/cfg80211.c
++++ b/drivers/net/wireless/mwifiex/cfg80211.c
+@@ -1462,7 +1462,7 @@ mwifiex_cfg80211_assoc(struct mwifiex_private *priv, size_t ssid_len, u8 *ssid,
+ 	struct cfg80211_ssid req_ssid;
+ 	int ret, auth_type = 0;
+ 	struct cfg80211_bss *bss = NULL;
+-	u8 is_scanning_required = 0, config_bands = 0;
++	u8 is_scanning_required = 0;
+ 
+ 	memset(&req_ssid, 0, sizeof(struct cfg80211_ssid));
+ 
+@@ -1481,19 +1481,6 @@ mwifiex_cfg80211_assoc(struct mwifiex_private *priv, size_t ssid_len, u8 *ssid,
+ 	/* disconnect before try to associate */
+ 	mwifiex_deauthenticate(priv, NULL);
+ 
+-	if (channel) {
+-		if (mode == NL80211_IFTYPE_STATION) {
+-			if (channel->band == IEEE80211_BAND_2GHZ)
+-				config_bands = BAND_B | BAND_G | BAND_GN;
+-			else
+-				config_bands = BAND_A | BAND_AN;
+-
+-			if (!((config_bands | priv->adapter->fw_bands) &
+-			      ~priv->adapter->fw_bands))
+-				priv->adapter->config_bands = config_bands;
+-		}
+-	}
+-
+ 	/* As this is new association, clear locally stored
+ 	 * keys and security related flags */
+ 	priv->sec_info.wpa_enabled = false;
+diff --git a/drivers/net/wireless/mwifiex/pcie.c b/drivers/net/wireless/mwifiex/pcie.c
+index 13fbc4e..b879e13 100644
+--- a/drivers/net/wireless/mwifiex/pcie.c
++++ b/drivers/net/wireless/mwifiex/pcie.c
+@@ -161,7 +161,7 @@ static int mwifiex_pcie_suspend(struct pci_dev *pdev, pm_message_t state)
+ 
+ 	if (pdev) {
+ 		card = (struct pcie_service_card *) pci_get_drvdata(pdev);
+-		if (!card || card->adapter) {
++		if (!card || !card->adapter) {
+ 			pr_err("Card or adapter structure is not valid\n");
+ 			return 0;
+ 		}
 diff --git a/drivers/net/wireless/mwifiex/sta_ioctl.c b/drivers/net/wireless/mwifiex/sta_ioctl.c
-index 0c9f70b..786bc11 100644
+index 0c9f70b..f3211d8 100644
 --- a/drivers/net/wireless/mwifiex/sta_ioctl.c
 +++ b/drivers/net/wireless/mwifiex/sta_ioctl.c
 @@ -56,7 +56,6 @@ int mwifiex_copy_mcast_addr(struct mwifiex_multicast_list *mlist,
@@ -7219,7 +9083,28 @@
  	}
  
  	status = adapter->cmd_wait_q.status;
-@@ -480,8 +476,11 @@ int mwifiex_enable_hs(struct mwifiex_adapter *adapter)
+@@ -269,6 +265,20 @@ int mwifiex_bss_start(struct mwifiex_private *priv, struct cfg80211_bss *bss,
+ 		if (ret)
+ 			goto done;
+ 
++		if (bss_desc) {
++			u8 config_bands = 0;
++
++			if (mwifiex_band_to_radio_type((u8) bss_desc->bss_band)
++			    == HostCmd_SCAN_RADIO_TYPE_BG)
++				config_bands = BAND_B | BAND_G | BAND_GN;
++			else
++				config_bands = BAND_A | BAND_AN;
++
++			if (!((config_bands | adapter->fw_bands) &
++			      ~adapter->fw_bands))
++				adapter->config_bands = config_bands;
++		}
++
+ 		ret = mwifiex_check_network_compatibility(priv, bss_desc);
+ 		if (ret)
+ 			goto done;
+@@ -480,8 +490,11 @@ int mwifiex_enable_hs(struct mwifiex_adapter *adapter)
  		return false;
  	}
  
@@ -7884,11 +9769,32 @@
  DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5CE823, ricoh_mmc_fixup_r5c832);
  DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5CE823, ricoh_mmc_fixup_r5c832);
  #endif /*CONFIG_MMC_RICOH_MMC*/
+diff --git a/drivers/platform/x86/ibm_rtl.c b/drivers/platform/x86/ibm_rtl.c
+index 7481146..97c2be1 100644
+--- a/drivers/platform/x86/ibm_rtl.c
++++ b/drivers/platform/x86/ibm_rtl.c
+@@ -244,7 +244,7 @@ static int __init ibm_rtl_init(void) {
+ 	if (force)
+ 		pr_warn("module loaded by force\n");
+ 	/* first ensure that we are running on IBM HW */
+-	else if (efi_enabled || !dmi_check_system(ibm_rtl_dmi_table))
++	else if (efi_enabled(EFI_BOOT) || !dmi_check_system(ibm_rtl_dmi_table))
+ 		return -ENODEV;
+ 
+ 	/* Get the address for the Extended BIOS Data Area */
 diff --git a/drivers/platform/x86/samsung-laptop.c b/drivers/platform/x86/samsung-laptop.c
-index dd90d15..71623a2 100644
+index dd90d15..d1f0300 100644
 --- a/drivers/platform/x86/samsung-laptop.c
 +++ b/drivers/platform/x86/samsung-laptop.c
-@@ -1523,6 +1523,16 @@ static struct dmi_system_id __initdata samsung_dmi_table[] = {
+@@ -26,6 +26,7 @@
+ #include <linux/seq_file.h>
+ #include <linux/debugfs.h>
+ #include <linux/ctype.h>
++#include <linux/efi.h>
+ #include <acpi/video.h>
+ 
+ /*
+@@ -1523,6 +1524,16 @@ static struct dmi_system_id __initdata samsung_dmi_table[] = {
  		},
  	 .driver_data = &samsung_broken_acpi_video,
  	},
@@ -7905,6 +9811,16 @@
  	{ },
  };
  MODULE_DEVICE_TABLE(dmi, samsung_dmi_table);
+@@ -1534,6 +1545,9 @@ static int __init samsung_init(void)
+ 	struct samsung_laptop *samsung;
+ 	int ret;
+ 
++	if (efi_enabled(EFI_BOOT))
++		return -ENODEV;
++
+ 	quirks = &samsung_unknown;
+ 	if (!force && !dmi_check_system(samsung_dmi_table))
+ 		return -ENODEV;
 diff --git a/drivers/platform/x86/sony-laptop.c b/drivers/platform/x86/sony-laptop.c
 index daaddec..b8ad71f 100644
 --- a/drivers/platform/x86/sony-laptop.c
@@ -8367,6 +10283,19 @@
  		      id->devno, rc, cdev->private->pgid_valid_mask, sch->vpm,
  		      cdev->private->pgid_todo_mask, mismatch, reserved, reset);
  	switch (rc) {
+diff --git a/drivers/scsi/isci/init.c b/drivers/scsi/isci/init.c
+index b74050b..9ac1e9d 100644
+--- a/drivers/scsi/isci/init.c
++++ b/drivers/scsi/isci/init.c
+@@ -633,7 +633,7 @@ static int __devinit isci_pci_probe(struct pci_dev *pdev, const struct pci_devic
+ 		return -ENOMEM;
+ 	pci_set_drvdata(pdev, pci_info);
+ 
+-	if (efi_enabled)
++	if (efi_enabled(EFI_RUNTIME_SERVICES))
+ 		orom = isci_get_efi_var(pdev);
+ 
+ 	if (!orom)
 diff --git a/drivers/scsi/mvsas/mv_94xx.h b/drivers/scsi/mvsas/mv_94xx.h
 index 8f7eb4f..487aa6f 100644
 --- a/drivers/scsi/mvsas/mv_94xx.h
@@ -10086,7 +12015,7 @@
  	g_lun0_dev = dev;
  
 diff --git a/drivers/target/target_core_fabric_configfs.c b/drivers/target/target_core_fabric_configfs.c
-index bca737b..a55f91a 100644
+index bca737b..9430cd2 100644
 --- a/drivers/target/target_core_fabric_configfs.c
 +++ b/drivers/target/target_core_fabric_configfs.c
 @@ -71,6 +71,12 @@ static int target_fabric_mappedlun_link(
@@ -10102,19 +12031,18 @@
  	/*
  	 * Ensure that the source port exists
  	 */
-@@ -745,6 +751,12 @@ static int target_fabric_port_link(
- 	struct target_fabric_configfs *tf;
- 	int ret;
- 
+@@ -762,6 +768,11 @@ static int target_fabric_port_link(
+ 		ret = -ENODEV;
+ 		goto out;
+ 	}
 +	if (dev->dev_link_magic != SE_DEV_LINK_MAGIC) {
 +		pr_err("Bad dev->dev_link_magic, not a valid se_dev_ci pointer:"
 +			" %p to struct se_device: %p\n", se_dev_ci, dev);
 +		return -EFAULT;
 +	}
-+
- 	tpg_ci = &lun_ci->ci_parent->ci_group->cg_item;
- 	se_tpg = container_of(to_config_group(tpg_ci),
- 				struct se_portal_group, tpg_group);
+ 
+ 	lun_p = core_dev_add_lun(se_tpg, dev, lun->unpacked_lun);
+ 	if (IS_ERR(lun_p)) {
 diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c
 index 0360383..c639b42 100644
 --- a/drivers/target/target_core_file.c
@@ -12377,6 +14305,19 @@
  	if (opt->osd_keepalive_timeout != CEPH_OSD_KEEPALIVE_DEFAULT)
  		seq_printf(m, ",osdkeepalivetimeout=%d",
  			   opt->osd_keepalive_timeout);
+diff --git a/fs/cifs/cifs_dfs_ref.c b/fs/cifs/cifs_dfs_ref.c
+index ce5cbd7..210fce2 100644
+--- a/fs/cifs/cifs_dfs_ref.c
++++ b/fs/cifs/cifs_dfs_ref.c
+@@ -226,6 +226,8 @@ compose_mount_options_out:
+ compose_mount_options_err:
+ 	kfree(mountdata);
+ 	mountdata = ERR_PTR(rc);
++	kfree(*devname);
++	*devname = NULL;
+ 	goto compose_mount_options_out;
+ }
+ 
 diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c
 index 1c576e8..dd538b4 100644
 --- a/fs/cifs/readdir.c
@@ -12997,6 +14938,180 @@
  		if (!PageCompound(page)) {
  			if (test_bit(NFS_IOHDR_ERROR, &hdr->flags)) {
  				if (bytes < hdr->good_bytes)
+diff --git a/fs/nfs/namespace.c b/fs/nfs/namespace.c
+index dd057bc..fc8dc20 100644
+--- a/fs/nfs/namespace.c
++++ b/fs/nfs/namespace.c
+@@ -177,11 +177,31 @@ out_nofree:
+ 	return mnt;
+ }
+ 
++static int
++nfs_namespace_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
++{
++	if (NFS_FH(dentry->d_inode)->size != 0)
++		return nfs_getattr(mnt, dentry, stat);
++	generic_fillattr(dentry->d_inode, stat);
++	return 0;
++}
++
++static int
++nfs_namespace_setattr(struct dentry *dentry, struct iattr *attr)
++{
++	if (NFS_FH(dentry->d_inode)->size != 0)
++		return nfs_setattr(dentry, attr);
++	return -EACCES;
++}
++
+ const struct inode_operations nfs_mountpoint_inode_operations = {
+ 	.getattr	= nfs_getattr,
++	.setattr	= nfs_setattr,
+ };
+ 
+ const struct inode_operations nfs_referral_inode_operations = {
++	.getattr	= nfs_namespace_getattr,
++	.setattr	= nfs_namespace_setattr,
+ };
+ 
+ static void nfs_expire_automounts(struct work_struct *work)
+diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c
+index 6bacfde..1f55131 100644
+--- a/fs/nfs/nfs4client.c
++++ b/fs/nfs/nfs4client.c
+@@ -235,11 +235,10 @@ struct nfs_client *nfs4_init_client(struct nfs_client *clp,
+ 	error = nfs4_discover_server_trunking(clp, &old);
+ 	if (error < 0)
+ 		goto error;
++	nfs_put_client(clp);
+ 	if (clp != old) {
+ 		clp->cl_preserve_clid = true;
+-		nfs_put_client(clp);
+ 		clp = old;
+-		atomic_inc(&clp->cl_count);
+ 	}
+ 
+ 	return clp;
+@@ -305,7 +304,7 @@ int nfs40_walk_client_list(struct nfs_client *new,
+ 		.clientid	= new->cl_clientid,
+ 		.confirm	= new->cl_confirm,
+ 	};
+-	int status;
++	int status = -NFS4ERR_STALE_CLIENTID;
+ 
+ 	spin_lock(&nn->nfs_client_lock);
+ 	list_for_each_entry_safe(pos, n, &nn->nfs_client_list, cl_share_link) {
+@@ -331,40 +330,33 @@ int nfs40_walk_client_list(struct nfs_client *new,
+ 
+ 		if (prev)
+ 			nfs_put_client(prev);
++		prev = pos;
+ 
+ 		status = nfs4_proc_setclientid_confirm(pos, &clid, cred);
+-		if (status == 0) {
++		switch (status) {
++		case -NFS4ERR_STALE_CLIENTID:
++			break;
++		case 0:
+ 			nfs4_swap_callback_idents(pos, new);
+ 
+-			nfs_put_client(pos);
++			prev = NULL;
+ 			*result = pos;
+ 			dprintk("NFS: <-- %s using nfs_client = %p ({%d})\n",
+ 				__func__, pos, atomic_read(&pos->cl_count));
+-			return 0;
+-		}
+-		if (status != -NFS4ERR_STALE_CLIENTID) {
+-			nfs_put_client(pos);
+-			dprintk("NFS: <-- %s status = %d, no result\n",
+-				__func__, status);
+-			return status;
++		default:
++			goto out;
+ 		}
+ 
+ 		spin_lock(&nn->nfs_client_lock);
+-		prev = pos;
+ 	}
++	spin_unlock(&nn->nfs_client_lock);
+ 
+-	/*
+-	 * No matching nfs_client found.  This should be impossible,
+-	 * because the new nfs_client has already been added to
+-	 * nfs_client_list by nfs_get_client().
+-	 *
+-	 * Don't BUG(), since the caller is holding a mutex.
+-	 */
++	/* No match found. The server lost our clientid */
++out:
+ 	if (prev)
+ 		nfs_put_client(prev);
+-	spin_unlock(&nn->nfs_client_lock);
+-	pr_err("NFS: %s Error: no matching nfs_client found\n", __func__);
+-	return -NFS4ERR_STALE_CLIENTID;
++	dprintk("NFS: <-- %s status = %d\n", __func__, status);
++	return status;
+ }
+ 
+ #ifdef CONFIG_NFS_V4_1
+@@ -431,7 +423,7 @@ int nfs41_walk_client_list(struct nfs_client *new,
+ {
+ 	struct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);
+ 	struct nfs_client *pos, *n, *prev = NULL;
+-	int error;
++	int status = -NFS4ERR_STALE_CLIENTID;
+ 
+ 	spin_lock(&nn->nfs_client_lock);
+ 	list_for_each_entry_safe(pos, n, &nn->nfs_client_list, cl_share_link) {
+@@ -447,14 +439,17 @@ int nfs41_walk_client_list(struct nfs_client *new,
+ 				nfs_put_client(prev);
+ 			prev = pos;
+ 
+-			error = nfs_wait_client_init_complete(pos);
+-			if (error < 0) {
++			nfs4_schedule_lease_recovery(pos);
++			status = nfs_wait_client_init_complete(pos);
++			if (status < 0) {
+ 				nfs_put_client(pos);
+ 				spin_lock(&nn->nfs_client_lock);
+ 				continue;
+ 			}
+-
++			status = pos->cl_cons_state;
+ 			spin_lock(&nn->nfs_client_lock);
++			if (status < 0)
++				continue;
+ 		}
+ 
+ 		if (pos->rpc_ops != new->rpc_ops)
+@@ -472,6 +467,7 @@ int nfs41_walk_client_list(struct nfs_client *new,
+ 		if (!nfs4_match_serverowners(pos, new))
+ 			continue;
+ 
++		atomic_inc(&pos->cl_count);
+ 		spin_unlock(&nn->nfs_client_lock);
+ 		dprintk("NFS: <-- %s using nfs_client = %p ({%d})\n",
+ 			__func__, pos, atomic_read(&pos->cl_count));
+@@ -480,16 +476,10 @@ int nfs41_walk_client_list(struct nfs_client *new,
+ 		return 0;
+ 	}
+ 
+-	/*
+-	 * No matching nfs_client found.  This should be impossible,
+-	 * because the new nfs_client has already been added to
+-	 * nfs_client_list by nfs_get_client().
+-	 *
+-	 * Don't BUG(), since the caller is holding a mutex.
+-	 */
++	/* No matching nfs_client found. */
+ 	spin_unlock(&nn->nfs_client_lock);
+-	pr_err("NFS: %s Error: no matching nfs_client found\n", __func__);
+-	return -NFS4ERR_STALE_CLIENTID;
++	dprintk("NFS: <-- %s status = %d\n", __func__, status);
++	return status;
+ }
+ #endif	/* CONFIG_NFS_V4_1 */
+ 
 diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
 index 5eec442..4432b2f 100644
 --- a/fs/nfs/nfs4proc.c
@@ -13110,6 +15225,57 @@
  	if (IS_ERR(task)) {
  		ret = PTR_ERR(task);
  		goto out;
+diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c
+index c351e6b..b1c96e7 100644
+--- a/fs/nfs/nfs4state.c
++++ b/fs/nfs/nfs4state.c
+@@ -136,16 +136,11 @@ int nfs40_discover_server_trunking(struct nfs_client *clp,
+ 	clp->cl_confirm = clid.confirm;
+ 
+ 	status = nfs40_walk_client_list(clp, result, cred);
+-	switch (status) {
+-	case -NFS4ERR_STALE_CLIENTID:
+-		set_bit(NFS4CLNT_LEASE_CONFIRM, &clp->cl_state);
+-	case 0:
++	if (status == 0) {
+ 		/* Sustain the lease, even if it's empty.  If the clientid4
+ 		 * goes stale it's of no use for trunking discovery. */
+ 		nfs4_schedule_state_renewal(*result);
+-		break;
+ 	}
+-
+ out:
+ 	return status;
+ }
+@@ -1850,6 +1845,7 @@ again:
+ 	case -ETIMEDOUT:
+ 	case -EAGAIN:
+ 		ssleep(1);
++	case -NFS4ERR_STALE_CLIENTID:
+ 		dprintk("NFS: %s after status %d, retrying\n",
+ 			__func__, status);
+ 		goto again;
+@@ -2001,8 +1997,18 @@ static int nfs4_reset_session(struct nfs_client *clp)
+ 	nfs4_begin_drain_session(clp);
+ 	cred = nfs4_get_exchange_id_cred(clp);
+ 	status = nfs4_proc_destroy_session(clp->cl_session, cred);
+-	if (status && status != -NFS4ERR_BADSESSION &&
+-	    status != -NFS4ERR_DEADSESSION) {
++	switch (status) {
++	case 0:
++	case -NFS4ERR_BADSESSION:
++	case -NFS4ERR_DEADSESSION:
++		break;
++	case -NFS4ERR_BACK_CHAN_BUSY:
++	case -NFS4ERR_DELAY:
++		set_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);
++		status = 0;
++		ssleep(1);
++		goto out;
++	default:
+ 		status = nfs4_recovery_handle_error(clp, status);
+ 		goto out;
+ 	}
 diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c
 index 2878f97..b7f7538 100644
 --- a/fs/nfs/pnfs.c
@@ -13148,7 +15314,7 @@
  EXPORT_SYMBOL_GPL(nfs_readdata_release);
  
 diff --git a/fs/nfs/super.c b/fs/nfs/super.c
-index 652d3f7..00be08f 100644
+index 652d3f7..49f3f90 100644
 --- a/fs/nfs/super.c
 +++ b/fs/nfs/super.c
 @@ -1150,7 +1150,7 @@ static int nfs_get_option_str(substring_t args[], char **option)
@@ -13160,6 +15326,43 @@
  }
  
  static int nfs_get_option_ul(substring_t args[], unsigned long *option)
+@@ -2576,27 +2576,23 @@ nfs_xdev_mount(struct file_system_type *fs_type, int flags,
+ 	struct nfs_server *server;
+ 	struct dentry *mntroot = ERR_PTR(-ENOMEM);
+ 	struct nfs_subversion *nfs_mod = NFS_SB(data->sb)->nfs_client->cl_nfs_mod;
+-	int error;
+ 
+-	dprintk("--> nfs_xdev_mount_common()\n");
++	dprintk("--> nfs_xdev_mount()\n");
+ 
+ 	mount_info.mntfh = mount_info.cloned->fh;
+ 
+ 	/* create a new volume representation */
+ 	server = nfs_mod->rpc_ops->clone_server(NFS_SB(data->sb), data->fh, data->fattr, data->authflavor);
+-	if (IS_ERR(server)) {
+-		error = PTR_ERR(server);
+-		goto out_err;
+-	}
+ 
+-	mntroot = nfs_fs_mount_common(server, flags, dev_name, &mount_info, nfs_mod);
+-	dprintk("<-- nfs_xdev_mount_common() = 0\n");
+-out:
+-	return mntroot;
++	if (IS_ERR(server))
++		mntroot = ERR_CAST(server);
++	else
++		mntroot = nfs_fs_mount_common(server, flags,
++				dev_name, &mount_info, nfs_mod);
+ 
+-out_err:
+-	dprintk("<-- nfs_xdev_mount_common() = %d [error]\n", error);
+-	goto out;
++	dprintk("<-- nfs_xdev_mount() = %ld\n",
++			IS_ERR(mntroot) ? PTR_ERR(mntroot) : 0L);
++	return mntroot;
+ }
+ 
+ #if IS_ENABLED(CONFIG_NFS_V4)
 diff --git a/fs/nfs/write.c b/fs/nfs/write.c
 index 9347ab7..8b67dc3 100644
 --- a/fs/nfs/write.c
@@ -13425,9 +15628,22 @@
  	newblock = udf_get_pblock(inode->i_sb, newblocknum,
  				iinfo->i_location.partitionReferenceNum, 0);
 diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c
-index e57e2da..e0e9ee0 100644
+index e57e2da..dfbcfd0 100644
 --- a/fs/xfs/xfs_aops.c
 +++ b/fs/xfs/xfs_aops.c
+@@ -86,11 +86,11 @@ xfs_destroy_ioend(
+ 	}
+ 
+ 	if (ioend->io_iocb) {
++		inode_dio_done(ioend->io_inode);
+ 		if (ioend->io_isasync) {
+ 			aio_complete(ioend->io_iocb, ioend->io_error ?
+ 					ioend->io_error : ioend->io_result, 0);
+ 		}
+-		inode_dio_done(ioend->io_inode);
+ 	}
+ 
+ 	mempool_free(ioend, xfs_ioend_pool);
 @@ -124,7 +124,7 @@ xfs_setfilesize_trans_alloc(
  	ioend->io_append_trans = tp;
  
@@ -13579,6 +15795,42 @@
  out_destroy_ioend:
  	xfs_destroy_ioend(ioend);
  	return ret;
+diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
+index 4b0b8dd..58a1f41 100644
+--- a/fs/xfs/xfs_buf.c
++++ b/fs/xfs/xfs_buf.c
+@@ -487,6 +487,7 @@ _xfs_buf_find(
+ 	struct rb_node		*parent;
+ 	xfs_buf_t		*bp;
+ 	xfs_daddr_t		blkno = map[0].bm_bn;
++	xfs_daddr_t		eofs;
+ 	int			numblks = 0;
+ 	int			i;
+ 
+@@ -498,6 +499,23 @@ _xfs_buf_find(
+ 	ASSERT(!(numbytes < (1 << btp->bt_sshift)));
+ 	ASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));
+ 
++	/*
++	 * Corrupted block numbers can get through to here, unfortunately, so we
++	 * have to check that the buffer falls within the filesystem bounds.
++	 */
++	eofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);
++	if (blkno >= eofs) {
++		/*
++		 * XXX (dgc): we should really be returning EFSCORRUPTED here,
++		 * but none of the higher level infrastructure supports
++		 * returning a specific error on buffer lookup failures.
++		 */
++		xfs_alert(btp->bt_mount,
++			  "%s: Block out of range: block 0x%llx, EOFS 0x%llx ",
++			  __func__, blkno, eofs);
++		return NULL;
++	}
++
+ 	/* get tree root */
+ 	pag = xfs_perag_get(btp->bt_mount,
+ 				xfs_daddr_to_agno(btp->bt_mount, blkno));
 diff --git a/fs/xfs/xfs_log.c b/fs/xfs/xfs_log.c
 index 4dad756..a54c292 100644
 --- a/fs/xfs/xfs_log.c
@@ -13651,6 +15903,19 @@
  	trace_xfs_dqreclaim_busy(dqp);
  	XFS_STATS_INC(xs_qm_dqreclaim_misses);
  }
+diff --git a/fs/xfs/xfs_sync.c b/fs/xfs/xfs_sync.c
+index 9500caf..7bf85e8 100644
+--- a/fs/xfs/xfs_sync.c
++++ b/fs/xfs/xfs_sync.c
+@@ -400,7 +400,7 @@ xfs_sync_worker(
+ 	 * cancel_delayed_work_sync on this work queue before tearing down
+ 	 * the ail and the log in xfs_log_unmount.
+ 	 */
+-	if (!(mp->m_super->s_flags & MS_ACTIVE) &&
++	if ((mp->m_super->s_flags & MS_ACTIVE) &&
+ 	    !(mp->m_flags & XFS_MOUNT_RDONLY)) {
+ 		/* dgc: errors ignored here */
+ 		if (mp->m_super->s_writers.frozen == SB_UNFROZEN &&
 diff --git a/include/asm-generic/tlb.h b/include/asm-generic/tlb.h
 index ed6642a..25f01d0 100644
 --- a/include/asm-generic/tlb.h
@@ -13791,6 +16056,47 @@
  {
  	return COMPACT_CONTINUE;
  }
+diff --git a/include/linux/efi.h b/include/linux/efi.h
+index 8670eb1..b424f64 100644
+--- a/include/linux/efi.h
++++ b/include/linux/efi.h
+@@ -542,18 +542,30 @@ extern int __init efi_setup_pcdp_console(char *);
+ #endif
+ 
+ /*
+- * We play games with efi_enabled so that the compiler will, if possible, remove
+- * EFI-related code altogether.
++ * We play games with efi_enabled so that the compiler will, if
++ * possible, remove EFI-related code altogether.
+  */
++#define EFI_BOOT		0	/* Were we booted from EFI? */
++#define EFI_SYSTEM_TABLES	1	/* Can we use EFI system tables? */
++#define EFI_CONFIG_TABLES	2	/* Can we use EFI config tables? */
++#define EFI_RUNTIME_SERVICES	3	/* Can we use runtime services? */
++#define EFI_MEMMAP		4	/* Can we use EFI memory map? */
++#define EFI_64BIT		5	/* Is the firmware 64-bit? */
++
+ #ifdef CONFIG_EFI
+ # ifdef CONFIG_X86
+-   extern int efi_enabled;
+-   extern bool efi_64bit;
++extern int efi_enabled(int facility);
+ # else
+-#  define efi_enabled 1
++static inline int efi_enabled(int facility)
++{
++	return 1;
++}
+ # endif
+ #else
+-# define efi_enabled 0
++static inline int efi_enabled(int facility)
++{
++	return 0;
++}
+ #endif
+ 
+ /*
 diff --git a/include/linux/freezer.h b/include/linux/freezer.h
 index d09af4b..ee89932 100644
 --- a/include/linux/freezer.h
@@ -14193,6 +16499,31 @@
  struct nd_opt_hdr {
  	__u8		nd_opt_type;
  	__u8		nd_opt_len;
+diff --git a/include/net/netfilter/nf_conntrack_core.h b/include/net/netfilter/nf_conntrack_core.h
+index d8f5b9f..e98aeb3 100644
+--- a/include/net/netfilter/nf_conntrack_core.h
++++ b/include/net/netfilter/nf_conntrack_core.h
+@@ -31,6 +31,8 @@ extern void nf_conntrack_cleanup(struct net *net);
+ extern int nf_conntrack_proto_init(struct net *net);
+ extern void nf_conntrack_proto_fini(struct net *net);
+ 
++extern void nf_conntrack_cleanup_end(void);
++
+ extern bool
+ nf_ct_get_tuple(const struct sk_buff *skb,
+ 		unsigned int nhoff,
+diff --git a/include/net/netns/x_tables.h b/include/net/netns/x_tables.h
+index 591db7d..c24060e 100644
+--- a/include/net/netns/x_tables.h
++++ b/include/net/netns/x_tables.h
+@@ -8,6 +8,7 @@ struct ebt_table;
+ 
+ struct netns_xt {
+ 	struct list_head tables[NFPROTO_NUMPROTO];
++	bool notrack_deprecated_warning;
+ #if defined(CONFIG_BRIDGE_NF_EBTABLES) || \
+     defined(CONFIG_BRIDGE_NF_EBTABLES_MODULE)
+ 	struct ebt_table *broute_table;
 diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h
 index 5be8937..fca8bbe 100644
 --- a/include/target/target_core_base.h
@@ -14271,9 +16602,27 @@
  	sys_chdir("/root");
  	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 diff --git a/init/main.c b/init/main.c
-index e33e09d..cd147a9 100644
+index e33e09d..857166f 100644
 --- a/init/main.c
 +++ b/init/main.c
+@@ -604,7 +604,7 @@ asmlinkage void __init start_kernel(void)
+ 	pidmap_init();
+ 	anon_vma_init();
+ #ifdef CONFIG_X86
+-	if (efi_enabled)
++	if (efi_enabled(EFI_RUNTIME_SERVICES))
+ 		efi_enter_virtual_mode();
+ #endif
+ 	thread_info_cache_init();
+@@ -632,7 +632,7 @@ asmlinkage void __init start_kernel(void)
+ 	acpi_early_init(); /* before LAPIC and SMP init */
+ 	sfi_init_late();
+ 
+-	if (efi_enabled) {
++	if (efi_enabled(EFI_RUNTIME_SERVICES)) {
+ 		efi_late_init();
+ 		efi_free_boot_services();
+ 	}
 @@ -800,7 +800,7 @@ static int run_init_process(const char *init_filename)
  	return kernel_execve(init_filename, argv_init, envp_init);
  }
@@ -15273,6 +17622,58 @@
  	set_current_blocked(&newset);
  
  	return old;
+diff --git a/kernel/smp.c b/kernel/smp.c
+index 29dd40a..69f38bd 100644
+--- a/kernel/smp.c
++++ b/kernel/smp.c
+@@ -33,6 +33,7 @@ struct call_function_data {
+ 	struct call_single_data	csd;
+ 	atomic_t		refs;
+ 	cpumask_var_t		cpumask;
++	cpumask_var_t		cpumask_ipi;
+ };
+ 
+ static DEFINE_PER_CPU_SHARED_ALIGNED(struct call_function_data, cfd_data);
+@@ -56,6 +57,9 @@ hotplug_cfd(struct notifier_block *nfb, unsigned long action, void *hcpu)
+ 		if (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,
+ 				cpu_to_node(cpu)))
+ 			return notifier_from_errno(-ENOMEM);
++		if (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,
++				cpu_to_node(cpu)))
++			return notifier_from_errno(-ENOMEM);
+ 		break;
+ 
+ #ifdef CONFIG_HOTPLUG_CPU
+@@ -65,6 +69,7 @@ hotplug_cfd(struct notifier_block *nfb, unsigned long action, void *hcpu)
+ 	case CPU_DEAD:
+ 	case CPU_DEAD_FROZEN:
+ 		free_cpumask_var(cfd->cpumask);
++		free_cpumask_var(cfd->cpumask_ipi);
+ 		break;
+ #endif
+ 	};
+@@ -526,6 +531,12 @@ void smp_call_function_many(const struct cpumask *mask,
+ 		return;
+ 	}
+ 
++	/*
++	 * After we put an entry into the list, data->cpumask
++	 * may be cleared again when another CPU sends another IPI for
++	 * a SMP function call, so data->cpumask will be zero.
++	 */
++	cpumask_copy(data->cpumask_ipi, data->cpumask);
+ 	raw_spin_lock_irqsave(&call_function.lock, flags);
+ 	/*
+ 	 * Place entry at the _HEAD_ of the list, so that any cpu still
+@@ -549,7 +560,7 @@ void smp_call_function_many(const struct cpumask *mask,
+ 	smp_mb();
+ 
+ 	/* Send a message to all CPUs in the map */
+-	arch_send_call_function_ipi_mask(data->cpumask);
++	arch_send_call_function_ipi_mask(data->cpumask_ipi);
+ 
+ 	/* Optionally wait for the CPUs to complete */
+ 	if (wait)
 diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
 index 9dcf15d..356bc2f 100644
 --- a/kernel/trace/ftrace.c
@@ -16182,6 +18583,18 @@
  	return (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;
  #endif /* CONFIG_SPARSEMEM */
  }
+diff --git a/mm/slub.c b/mm/slub.c
+index a0d6984..321afab 100644
+--- a/mm/slub.c
++++ b/mm/slub.c
+@@ -3279,6 +3279,7 @@ static struct kmem_cache *__init create_kmalloc_cache(const char *name,
+ 	if (kmem_cache_open(s, flags))
+ 		goto panic;
+ 
++	s->refcount = 1;
+ 	list_add(&s->list, &slab_caches);
+ 	return s;
+ 
 diff --git a/net/9p/trans_virtio.c b/net/9p/trans_virtio.c
 index 35b8911..fd05c81 100644
 --- a/net/9p/trans_virtio.c
@@ -16229,6 +18642,32 @@
  	if (!test_bit(HCI_INIT, &hdev->flags) &&
  	    !test_bit(HCI_SETUP, &hdev->dev_flags)) {
  		hci_dev_lock(hdev);
+diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
+index 2022b43..7c40d1e 100644
+--- a/net/bluetooth/hci_event.c
++++ b/net/bluetooth/hci_event.c
+@@ -2394,7 +2394,7 @@ static void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
+ 	if (ev->opcode != HCI_OP_NOP)
+ 		del_timer(&hdev->cmd_timer);
+ 
+-	if (ev->ncmd) {
++	if (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags)) {
+ 		atomic_set(&hdev->cmd_cnt, 1);
+ 		if (!skb_queue_empty(&hdev->cmd_q))
+ 			queue_work(hdev->workqueue, &hdev->cmd_work);
+diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
+index ccd985d..03652f3 100644
+--- a/net/bluetooth/hidp/core.c
++++ b/net/bluetooth/hidp/core.c
+@@ -931,7 +931,7 @@ static int hidp_setup_hid(struct hidp_session *session,
+ 	hid->version = req->version;
+ 	hid->country = req->country;
+ 
+-	strncpy(hid->name, req->name, 128);
++	strncpy(hid->name, req->name, sizeof(req->name) - 1);
+ 	strncpy(hid->phys, batostr(&bt_sk(session->ctrl_sock->sk)->src), 64);
+ 	strncpy(hid->uniq, batostr(&bt_sk(session->ctrl_sock->sk)->dst), 64);
+ 
 diff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c
 index b3226f3..868a909 100644
 --- a/net/bluetooth/rfcomm/sock.c
@@ -16840,6 +19279,18 @@
  int inet_csk_listen_start(struct sock *sk, const int nr_table_entries)
  {
  	struct inet_sock *inet = inet_sk(sk);
+diff --git a/net/ipv4/netfilter/ipt_REJECT.c b/net/ipv4/netfilter/ipt_REJECT.c
+index 51f13f8..04b18c1 100644
+--- a/net/ipv4/netfilter/ipt_REJECT.c
++++ b/net/ipv4/netfilter/ipt_REJECT.c
+@@ -81,6 +81,7 @@ static void send_reset(struct sk_buff *oldskb, int hook)
+ 	niph->saddr	= oiph->daddr;
+ 	niph->daddr	= oiph->saddr;
+ 
++	skb_reset_transport_header(nskb);
+ 	tcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));
+ 	memset(tcph, 0, sizeof(*tcph));
+ 	tcph->source	= oth->dest;
 diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
 index 0c4a643..bc3cb46 100644
 --- a/net/ipv4/tcp_ipv4.c
@@ -16892,6 +19343,34 @@
  	icmpv6_notify(skb, NDISC_REDIRECT, 0, 0);
  }
  
+diff --git a/net/ipv6/netfilter/ip6t_REJECT.c b/net/ipv6/netfilter/ip6t_REJECT.c
+index fd4fb34..029623d 100644
+--- a/net/ipv6/netfilter/ip6t_REJECT.c
++++ b/net/ipv6/netfilter/ip6t_REJECT.c
+@@ -132,6 +132,7 @@ static void send_reset(struct net *net, struct sk_buff *oldskb)
+ 	ip6h->saddr = oip6h->daddr;
+ 	ip6h->daddr = oip6h->saddr;
+ 
++	skb_reset_transport_header(nskb);
+ 	tcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));
+ 	/* Truncate to length (no data) */
+ 	tcph->doff = sizeof(struct tcphdr)/4;
+diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
+index 22c8ea9..3dacecc 100644
+--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
++++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
+@@ -311,7 +311,10 @@ found:
+ 	else
+ 		fq->q.fragments = skb;
+ 
+-	skb->dev = NULL;
++	if (skb->dev) {
++		fq->iif = skb->dev->ifindex;
++		skb->dev = NULL;
++	}
+ 	fq->q.stamp = skb->tstamp;
+ 	fq->q.meat += skb->len;
+ 	if (payload_len > fq->q.max_size)
 diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
 index 26175bf..73f2a6b 100644
 --- a/net/ipv6/tcp_ipv6.c
@@ -16906,6 +19385,29 @@
  		goto out;
  	}
  	__inet6_hash(newsk, NULL);
+diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
+index 7371f67..494da7f 100644
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -164,7 +164,17 @@ static int ieee80211_add_key(struct wiphy *wiphy, struct net_device *dev,
+ 			sta = sta_info_get(sdata, mac_addr);
+ 		else
+ 			sta = sta_info_get_bss(sdata, mac_addr);
+-		if (!sta) {
++		/*
++		 * The ASSOC test makes sure the driver is ready to
++		 * receive the key. When wpa_supplicant has roamed
++		 * using FT, it attempts to set the key before
++		 * association has completed, this rejects that attempt
++		 * so it will set the key again after assocation.
++		 *
++		 * TODO: accept the key if we have a station entry and
++		 *       add it to the device after the station.
++		 */
++		if (!sta || !test_sta_flag(sta, WLAN_STA_ASSOC)) {
+ 			ieee80211_key_free(sdata->local, key);
+ 			err = -ENOENT;
+ 			goto out_unlock;
 diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c
 index c21e33d..d9df6b8 100644
 --- a/net/mac80211/ibss.c
@@ -16934,7 +19436,7 @@
  		int interval = IEEE80211_SCAN_INTERVAL;
  
 diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
-index 156e583..3da215c 100644
+index 156e583..493e2e8 100644
 --- a/net/mac80211/ieee80211_i.h
 +++ b/net/mac80211/ieee80211_i.h
 @@ -730,6 +730,10 @@ struct ieee80211_sub_if_data {
@@ -16961,6 +19463,19 @@
  int ieee80211_request_scan(struct ieee80211_sub_if_data *sdata,
  			   struct cfg80211_scan_request *req);
  void ieee80211_scan_cancel(struct ieee80211_local *local);
+@@ -1275,10 +1279,8 @@ int ieee80211_request_sched_scan_stop(struct ieee80211_sub_if_data *sdata);
+ void ieee80211_sched_scan_stopped_work(struct work_struct *work);
+ 
+ /* off-channel helpers */
+-void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local,
+-				    bool offchannel_ps_enable);
+-void ieee80211_offchannel_return(struct ieee80211_local *local,
+-				 bool offchannel_ps_disable);
++void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local);
++void ieee80211_offchannel_return(struct ieee80211_local *local);
+ void ieee80211_roc_setup(struct ieee80211_local *local);
+ void ieee80211_start_next_roc(struct ieee80211_local *local);
+ void ieee80211_roc_purge(struct ieee80211_sub_if_data *sdata);
 diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
 index 7de7717..0f5af91 100644
 --- a/net/mac80211/iface.c
@@ -17016,11 +19531,112 @@
  	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
  		struct ieee80211_supported_band *sband;
  		sband = local->hw.wiphy->bands[i];
+diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c
+index 2c84185..b88152f 100644
+--- a/net/mac80211/offchannel.c
++++ b/net/mac80211/offchannel.c
+@@ -102,8 +102,7 @@ static void ieee80211_offchannel_ps_disable(struct ieee80211_sub_if_data *sdata)
+ 	ieee80211_sta_reset_conn_monitor(sdata);
+ }
+ 
+-void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local,
+-				    bool offchannel_ps_enable)
++void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 
+@@ -131,8 +130,7 @@ void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local,
+ 
+ 		if (sdata->vif.type != NL80211_IFTYPE_MONITOR) {
+ 			netif_tx_stop_all_queues(sdata->dev);
+-			if (offchannel_ps_enable &&
+-			    (sdata->vif.type == NL80211_IFTYPE_STATION) &&
++			if (sdata->vif.type == NL80211_IFTYPE_STATION &&
+ 			    sdata->u.mgd.associated)
+ 				ieee80211_offchannel_ps_enable(sdata);
+ 		}
+@@ -140,8 +138,7 @@ void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local,
+ 	mutex_unlock(&local->iflist_mtx);
+ }
+ 
+-void ieee80211_offchannel_return(struct ieee80211_local *local,
+-				 bool offchannel_ps_disable)
++void ieee80211_offchannel_return(struct ieee80211_local *local)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 
+@@ -157,11 +154,9 @@ void ieee80211_offchannel_return(struct ieee80211_local *local,
+ 			continue;
+ 
+ 		/* Tell AP we're back */
+-		if (offchannel_ps_disable &&
+-		    sdata->vif.type == NL80211_IFTYPE_STATION) {
+-			if (sdata->u.mgd.associated)
+-				ieee80211_offchannel_ps_disable(sdata);
+-		}
++		if (sdata->vif.type == NL80211_IFTYPE_STATION &&
++		    sdata->u.mgd.associated)
++			ieee80211_offchannel_ps_disable(sdata);
+ 
+ 		if (sdata->vif.type != NL80211_IFTYPE_MONITOR) {
+ 			/*
+@@ -381,7 +376,7 @@ void ieee80211_sw_roc_work(struct work_struct *work)
+ 			local->tmp_channel = NULL;
+ 			ieee80211_hw_config(local, 0);
+ 
+-			ieee80211_offchannel_return(local, true);
++			ieee80211_offchannel_return(local);
+ 		}
+ 
+ 		ieee80211_recalc_idle(local);
 diff --git a/net/mac80211/scan.c b/net/mac80211/scan.c
-index 43e60b5..fab706f 100644
+index 43e60b5..f41b1bd 100644
 --- a/net/mac80211/scan.c
 +++ b/net/mac80211/scan.c
-@@ -819,9 +819,9 @@ int ieee80211_request_scan(struct ieee80211_sub_if_data *sdata,
+@@ -310,7 +310,7 @@ static void __ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted,
+ 	if (!was_hw_scan) {
+ 		ieee80211_configure_filter(local);
+ 		drv_sw_scan_complete(local);
+-		ieee80211_offchannel_return(local, true);
++		ieee80211_offchannel_return(local);
+ 	}
+ 
+ 	ieee80211_recalc_idle(local);
+@@ -355,7 +355,7 @@ static int ieee80211_start_sw_scan(struct ieee80211_local *local)
+ 	local->next_scan_state = SCAN_DECISION;
+ 	local->scan_channel_idx = 0;
+ 
+-	ieee80211_offchannel_stop_vifs(local, true);
++	ieee80211_offchannel_stop_vifs(local);
+ 
+ 	ieee80211_configure_filter(local);
+ 
+@@ -680,12 +680,8 @@ static void ieee80211_scan_state_suspend(struct ieee80211_local *local,
+ 	local->scan_channel = NULL;
+ 	ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);
+ 
+-	/*
+-	 * Re-enable vifs and beaconing.  Leave PS
+-	 * in off-channel state..will put that back
+-	 * on-channel at the end of scanning.
+-	 */
+-	ieee80211_offchannel_return(local, false);
++	/* disable PS */
++	ieee80211_offchannel_return(local);
+ 
+ 	*next_delay = HZ / 5;
+ 	/* afterwards, resume scan & go to next channel */
+@@ -695,8 +691,7 @@ static void ieee80211_scan_state_suspend(struct ieee80211_local *local,
+ static void ieee80211_scan_state_resume(struct ieee80211_local *local,
+ 					unsigned long *next_delay)
+ {
+-	/* PS already is in off-channel mode */
+-	ieee80211_offchannel_stop_vifs(local, false);
++	ieee80211_offchannel_stop_vifs(local);
+ 
+ 	if (local->ops->flush) {
+ 		drv_flush(local, false);
+@@ -819,9 +814,9 @@ int ieee80211_request_scan(struct ieee80211_sub_if_data *sdata,
  	return res;
  }
  
@@ -17033,7 +19649,7 @@
  {
  	struct ieee80211_local *local = sdata->local;
  	int ret = -EBUSY;
-@@ -835,22 +835,36 @@ int ieee80211_request_internal_scan(struct ieee80211_sub_if_data *sdata,
+@@ -835,22 +830,36 @@ int ieee80211_request_internal_scan(struct ieee80211_sub_if_data *sdata,
  
  	/* fill internal scan request */
  	if (!chan) {
@@ -17216,6 +19832,482 @@
  }
  
  static int
+diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
+index fefa514..49e96df 100644
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -680,6 +680,13 @@ config NETFILTER_XT_TARGET_NFQUEUE
+ 
+ 	  To compile it as a module, choose M here.  If unsure, say N.
+ 
++config NETFILTER_XT_TARGET_NOTRACK
++	tristate  '"NOTRACK" target support (DEPRECATED)'
++	depends on NF_CONNTRACK
++	depends on IP_NF_RAW || IP6_NF_RAW
++	depends on NETFILTER_ADVANCED
++	select NETFILTER_XT_TARGET_CT
++
+ config NETFILTER_XT_TARGET_RATEEST
+ 	tristate '"RATEEST" target support'
+ 	depends on NETFILTER_ADVANCED
+diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
+index 0f241be..ec02168 100644
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -1383,11 +1383,12 @@ void nf_conntrack_cleanup(struct net *net)
+ 	synchronize_net();
+ 	nf_conntrack_proto_fini(net);
+ 	nf_conntrack_cleanup_net(net);
++}
+ 
+-	if (net_eq(net, &init_net)) {
+-		RCU_INIT_POINTER(nf_ct_destroy, NULL);
+-		nf_conntrack_cleanup_init_net();
+-	}
++void nf_conntrack_cleanup_end(void)
++{
++	RCU_INIT_POINTER(nf_ct_destroy, NULL);
++	nf_conntrack_cleanup_init_net();
+ }
+ 
+ void *nf_ct_alloc_hashtable(unsigned int *sizep, int nulls)
+diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
+index 7bbfb3d..ef9e86e 100644
+--- a/net/netfilter/nf_conntrack_netlink.c
++++ b/net/netfilter/nf_conntrack_netlink.c
+@@ -2514,7 +2514,7 @@ ctnetlink_create_expect(struct net *net, u16 zone,
+ 	if (!help) {
+ 		if (!cda[CTA_EXPECT_TIMEOUT]) {
+ 			err = -EINVAL;
+-			goto out;
++			goto err_out;
+ 		}
+ 		exp->timeout.expires =
+ 		  jiffies + ntohl(nla_get_be32(cda[CTA_EXPECT_TIMEOUT])) * HZ;
+diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
+index 9b39432..df8aa3a 100644
+--- a/net/netfilter/nf_conntrack_standalone.c
++++ b/net/netfilter/nf_conntrack_standalone.c
+@@ -571,6 +571,7 @@ static int __init nf_conntrack_standalone_init(void)
+ static void __exit nf_conntrack_standalone_fini(void)
+ {
+ 	unregister_pernet_subsys(&nf_conntrack_net_ops);
++	nf_conntrack_cleanup_end();
+ }
+ 
+ module_init(nf_conntrack_standalone_init);
+diff --git a/net/netfilter/nfnetlink_log.c b/net/netfilter/nfnetlink_log.c
+index 9f199f2..92fd8ec 100644
+--- a/net/netfilter/nfnetlink_log.c
++++ b/net/netfilter/nfnetlink_log.c
+@@ -13,6 +13,7 @@
+  */
+ #include <linux/module.h>
+ #include <linux/skbuff.h>
++#include <linux/if_arp.h>
+ #include <linux/init.h>
+ #include <linux/ip.h>
+ #include <linux/ipv6.h>
+@@ -384,6 +385,7 @@ __build_packet_message(struct nfulnl_instance *inst,
+ 	struct nfgenmsg *nfmsg;
+ 	sk_buff_data_t old_tail = inst->skb->tail;
+ 	struct sock *sk;
++	const unsigned char *hwhdrp;
+ 
+ 	nlh = nlmsg_put(inst->skb, 0, 0,
+ 			NFNL_SUBSYS_ULOG << 8 | NFULNL_MSG_PACKET,
+@@ -485,9 +487,17 @@ __build_packet_message(struct nfulnl_instance *inst,
+ 	if (indev && skb_mac_header_was_set(skb)) {
+ 		if (nla_put_be16(inst->skb, NFULA_HWTYPE, htons(skb->dev->type)) ||
+ 		    nla_put_be16(inst->skb, NFULA_HWLEN,
+-				 htons(skb->dev->hard_header_len)) ||
+-		    nla_put(inst->skb, NFULA_HWHEADER, skb->dev->hard_header_len,
+-			    skb_mac_header(skb)))
++				 htons(skb->dev->hard_header_len)))
++			goto nla_put_failure;
++
++		hwhdrp = skb_mac_header(skb);
++
++		if (skb->dev->type == ARPHRD_SIT)
++			hwhdrp -= ETH_HLEN;
++
++		if (hwhdrp >= skb->head &&
++		    nla_put(inst->skb, NFULA_HWHEADER,
++			    skb->dev->hard_header_len, hwhdrp))
+ 			goto nla_put_failure;
+ 	}
+ 
+diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c
+index 8d987c3..7b3a9e5 100644
+--- a/net/netfilter/x_tables.c
++++ b/net/netfilter/x_tables.c
+@@ -345,19 +345,27 @@ int xt_find_revision(u8 af, const char *name, u8 revision, int target,
+ }
+ EXPORT_SYMBOL_GPL(xt_find_revision);
+ 
+-static char *textify_hooks(char *buf, size_t size, unsigned int mask)
++static char *
++textify_hooks(char *buf, size_t size, unsigned int mask, uint8_t nfproto)
+ {
+-	static const char *const names[] = {
++	static const char *const inetbr_names[] = {
+ 		"PREROUTING", "INPUT", "FORWARD",
+ 		"OUTPUT", "POSTROUTING", "BROUTING",
+ 	};
+-	unsigned int i;
++	static const char *const arp_names[] = {
++		"INPUT", "FORWARD", "OUTPUT",
++	};
++	const char *const *names;
++	unsigned int i, max;
+ 	char *p = buf;
+ 	bool np = false;
+ 	int res;
+ 
++	names = (nfproto == NFPROTO_ARP) ? arp_names : inetbr_names;
++	max   = (nfproto == NFPROTO_ARP) ? ARRAY_SIZE(arp_names) :
++	                                   ARRAY_SIZE(inetbr_names);
+ 	*p = '\0';
+-	for (i = 0; i < ARRAY_SIZE(names); ++i) {
++	for (i = 0; i < max; ++i) {
+ 		if (!(mask & (1 << i)))
+ 			continue;
+ 		res = snprintf(p, size, "%s%s", np ? "/" : "", names[i]);
+@@ -402,8 +410,10 @@ int xt_check_match(struct xt_mtchk_param *par,
+ 		pr_err("%s_tables: %s match: used from hooks %s, but only "
+ 		       "valid from %s\n",
+ 		       xt_prefix[par->family], par->match->name,
+-		       textify_hooks(used, sizeof(used), par->hook_mask),
+-		       textify_hooks(allow, sizeof(allow), par->match->hooks));
++		       textify_hooks(used, sizeof(used), par->hook_mask,
++		                     par->family),
++		       textify_hooks(allow, sizeof(allow), par->match->hooks,
++		                     par->family));
+ 		return -EINVAL;
+ 	}
+ 	if (par->match->proto && (par->match->proto != proto || inv_proto)) {
+@@ -575,8 +585,10 @@ int xt_check_target(struct xt_tgchk_param *par,
+ 		pr_err("%s_tables: %s target: used from hooks %s, but only "
+ 		       "usable from %s\n",
+ 		       xt_prefix[par->family], par->target->name,
+-		       textify_hooks(used, sizeof(used), par->hook_mask),
+-		       textify_hooks(allow, sizeof(allow), par->target->hooks));
++		       textify_hooks(used, sizeof(used), par->hook_mask,
++		                     par->family),
++		       textify_hooks(allow, sizeof(allow), par->target->hooks,
++		                     par->family));
+ 		return -EINVAL;
+ 	}
+ 	if (par->target->proto && (par->target->proto != proto || inv_proto)) {
+diff --git a/net/netfilter/xt_CT.c b/net/netfilter/xt_CT.c
+index ae7f5da..8461605 100644
+--- a/net/netfilter/xt_CT.c
++++ b/net/netfilter/xt_CT.c
+@@ -109,7 +109,7 @@ static int xt_ct_tg_check_v0(const struct xt_tgchk_param *par)
+ 	struct xt_ct_target_info *info = par->targinfo;
+ 	struct nf_conntrack_tuple t;
+ 	struct nf_conn *ct;
+-	int ret;
++	int ret = -EOPNOTSUPP;
+ 
+ 	if (info->flags & ~XT_CT_NOTRACK)
+ 		return -EINVAL;
+@@ -243,7 +243,7 @@ static int xt_ct_tg_check_v1(const struct xt_tgchk_param *par)
+ 	struct xt_ct_target_info_v1 *info = par->targinfo;
+ 	struct nf_conntrack_tuple t;
+ 	struct nf_conn *ct;
+-	int ret;
++	int ret = -EOPNOTSUPP;
+ 
+ 	if (info->flags & ~XT_CT_NOTRACK)
+ 		return -EINVAL;
+@@ -377,14 +377,60 @@ static struct xt_target xt_ct_tg_reg[] __read_mostly = {
+ 	},
+ };
+ 
++static unsigned int
++notrack_tg(struct sk_buff *skb, const struct xt_action_param *par)
++{
++	/* Previously seen (loopback)? Ignore. */
++	if (skb->nfct != NULL)
++		return XT_CONTINUE;
++
++	skb->nfct = &nf_ct_untracked_get()->ct_general;
++	skb->nfctinfo = IP_CT_NEW;
++	nf_conntrack_get(skb->nfct);
++
++	return XT_CONTINUE;
++}
++
++static int notrack_chk(const struct xt_tgchk_param *par)
++{
++	if (!par->net->xt.notrack_deprecated_warning) {
++		pr_info("netfilter: NOTRACK target is deprecated, "
++			"use CT instead or upgrade iptables\n");
++		par->net->xt.notrack_deprecated_warning = true;
++	}
++	return 0;
++}
++
++static struct xt_target notrack_tg_reg __read_mostly = {
++	.name		= "NOTRACK",
++	.revision	= 0,
++	.family		= NFPROTO_UNSPEC,
++	.checkentry	= notrack_chk,
++	.target		= notrack_tg,
++	.table		= "raw",
++	.me		= THIS_MODULE,
++};
++
+ static int __init xt_ct_tg_init(void)
+ {
+-	return xt_register_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));
++	int ret;
++
++	ret = xt_register_target(&notrack_tg_reg);
++	if (ret < 0)
++		return ret;
++
++	ret = xt_register_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));
++	if (ret < 0) {
++		xt_unregister_target(&notrack_tg_reg);
++		return ret;
++	}
++	return 0;
+ }
+ 
+ static void __exit xt_ct_tg_exit(void)
+ {
+ 	xt_unregister_targets(xt_ct_tg_reg, ARRAY_SIZE(xt_ct_tg_reg));
++	xt_unregister_target(&notrack_tg_reg);
+ }
+ 
+ module_init(xt_ct_tg_init);
+@@ -394,3 +440,5 @@ MODULE_LICENSE("GPL");
+ MODULE_DESCRIPTION("Xtables: connection tracking target");
+ MODULE_ALIAS("ipt_CT");
+ MODULE_ALIAS("ip6t_CT");
++MODULE_ALIAS("ipt_NOTRACK");
++MODULE_ALIAS("ip6t_NOTRACK");
+diff --git a/net/netfilter/xt_hashlimit.c b/net/netfilter/xt_hashlimit.c
+index 26a668a..a9d7af9 100644
+--- a/net/netfilter/xt_hashlimit.c
++++ b/net/netfilter/xt_hashlimit.c
+@@ -157,11 +157,22 @@ dsthash_find(const struct xt_hashlimit_htable *ht,
+ /* allocate dsthash_ent, initialize dst, put in htable and lock it */
+ static struct dsthash_ent *
+ dsthash_alloc_init(struct xt_hashlimit_htable *ht,
+-		   const struct dsthash_dst *dst)
++		   const struct dsthash_dst *dst, bool *race)
+ {
+ 	struct dsthash_ent *ent;
+ 
+ 	spin_lock(&ht->lock);
++
++	/* Two or more packets may race to create the same entry in the
++	 * hashtable, double check if this packet lost race.
++	 */
++	ent = dsthash_find(ht, dst);
++	if (ent != NULL) {
++		spin_unlock(&ht->lock);
++		*race = true;
++		return ent;
++	}
++
+ 	/* initialize hash with random val at the time we allocate
+ 	 * the first hashtable entry */
+ 	if (unlikely(!ht->rnd_initialized)) {
+@@ -318,7 +329,10 @@ static void htable_destroy(struct xt_hashlimit_htable *hinfo)
+ 		parent = hashlimit_net->ipt_hashlimit;
+ 	else
+ 		parent = hashlimit_net->ip6t_hashlimit;
+-	remove_proc_entry(hinfo->pde->name, parent);
++
++	if(parent != NULL)
++		remove_proc_entry(hinfo->pde->name, parent);
++
+ 	htable_selective_cleanup(hinfo, select_all);
+ 	vfree(hinfo);
+ }
+@@ -585,6 +599,7 @@ hashlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)
+ 	unsigned long now = jiffies;
+ 	struct dsthash_ent *dh;
+ 	struct dsthash_dst dst;
++	bool race = false;
+ 	u32 cost;
+ 
+ 	if (hashlimit_init_dst(hinfo, &dst, skb, par->thoff) < 0)
+@@ -593,13 +608,18 @@ hashlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)
+ 	rcu_read_lock_bh();
+ 	dh = dsthash_find(hinfo, &dst);
+ 	if (dh == NULL) {
+-		dh = dsthash_alloc_init(hinfo, &dst);
++		dh = dsthash_alloc_init(hinfo, &dst, &race);
+ 		if (dh == NULL) {
+ 			rcu_read_unlock_bh();
+ 			goto hotdrop;
++		} else if (race) {
++			/* Already got an entry, update expiration timeout */
++			dh->expires = now + msecs_to_jiffies(hinfo->cfg.expire);
++			rateinfo_recalc(dh, now, hinfo->cfg.mode);
++		} else {
++			dh->expires = jiffies + msecs_to_jiffies(hinfo->cfg.expire);
++			rateinfo_init(dh, hinfo);
+ 		}
+-		dh->expires = jiffies + msecs_to_jiffies(hinfo->cfg.expire);
+-		rateinfo_init(dh, hinfo);
+ 	} else {
+ 		/* update expiration timeout */
+ 		dh->expires = now + msecs_to_jiffies(hinfo->cfg.expire);
+@@ -856,6 +876,27 @@ static int __net_init hashlimit_proc_net_init(struct net *net)
+ 
+ static void __net_exit hashlimit_proc_net_exit(struct net *net)
+ {
++	struct xt_hashlimit_htable *hinfo;
++	struct hlist_node *pos;
++	struct proc_dir_entry *pde;
++	struct hashlimit_net *hashlimit_net = hashlimit_pernet(net);
++
++	/* recent_net_exit() is called before recent_mt_destroy(). Make sure
++	 * that the parent xt_recent proc entry is is empty before trying to
++	 * remove it.
++	 */
++	mutex_lock(&hashlimit_mutex);
++	pde = hashlimit_net->ipt_hashlimit;
++	if (pde == NULL)
++		pde = hashlimit_net->ip6t_hashlimit;
++
++	hlist_for_each_entry(hinfo, pos, &hashlimit_net->htables, node)
++		remove_proc_entry(hinfo->pde->name, pde);
++
++	hashlimit_net->ipt_hashlimit = NULL;
++	hashlimit_net->ip6t_hashlimit = NULL;
++	mutex_unlock(&hashlimit_mutex);
++
+ 	proc_net_remove(net, "ipt_hashlimit");
+ #if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)
+ 	proc_net_remove(net, "ip6t_hashlimit");
+@@ -872,9 +913,6 @@ static int __net_init hashlimit_net_init(struct net *net)
+ 
+ static void __net_exit hashlimit_net_exit(struct net *net)
+ {
+-	struct hashlimit_net *hashlimit_net = hashlimit_pernet(net);
+-
+-	BUG_ON(!hlist_empty(&hashlimit_net->htables));
+ 	hashlimit_proc_net_exit(net);
+ }
+ 
+diff --git a/net/netfilter/xt_recent.c b/net/netfilter/xt_recent.c
+index 4635c9b..978efc9 100644
+--- a/net/netfilter/xt_recent.c
++++ b/net/netfilter/xt_recent.c
+@@ -29,6 +29,7 @@
+ #include <linux/skbuff.h>
+ #include <linux/inet.h>
+ #include <linux/slab.h>
++#include <linux/vmalloc.h>
+ #include <net/net_namespace.h>
+ #include <net/netns/generic.h>
+ 
+@@ -310,6 +311,14 @@ out:
+ 	return ret;
+ }
+ 
++static void recent_table_free(void *addr)
++{
++	if (is_vmalloc_addr(addr))
++		vfree(addr);
++	else
++		kfree(addr);
++}
++
+ static int recent_mt_check(const struct xt_mtchk_param *par,
+ 			   const struct xt_recent_mtinfo_v1 *info)
+ {
+@@ -322,6 +331,7 @@ static int recent_mt_check(const struct xt_mtchk_param *par,
+ #endif
+ 	unsigned int i;
+ 	int ret = -EINVAL;
++	size_t sz;
+ 
+ 	if (unlikely(!hash_rnd_inited)) {
+ 		get_random_bytes(&hash_rnd, sizeof(hash_rnd));
+@@ -360,8 +370,11 @@ static int recent_mt_check(const struct xt_mtchk_param *par,
+ 		goto out;
+ 	}
+ 
+-	t = kzalloc(sizeof(*t) + sizeof(t->iphash[0]) * ip_list_hash_size,
+-		    GFP_KERNEL);
++	sz = sizeof(*t) + sizeof(t->iphash[0]) * ip_list_hash_size;
++	if (sz <= PAGE_SIZE)
++		t = kzalloc(sz, GFP_KERNEL);
++	else
++		t = vzalloc(sz);
+ 	if (t == NULL) {
+ 		ret = -ENOMEM;
+ 		goto out;
+@@ -377,14 +390,14 @@ static int recent_mt_check(const struct xt_mtchk_param *par,
+ 	uid = make_kuid(&init_user_ns, ip_list_uid);
+ 	gid = make_kgid(&init_user_ns, ip_list_gid);
+ 	if (!uid_valid(uid) || !gid_valid(gid)) {
+-		kfree(t);
++		recent_table_free(t);
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 	pde = proc_create_data(t->name, ip_list_perms, recent_net->xt_recent,
+ 		  &recent_mt_fops, t);
+ 	if (pde == NULL) {
+-		kfree(t);
++		recent_table_free(t);
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+@@ -431,10 +444,11 @@ static void recent_mt_destroy(const struct xt_mtdtor_param *par)
+ 		list_del(&t->list);
+ 		spin_unlock_bh(&recent_lock);
+ #ifdef CONFIG_PROC_FS
+-		remove_proc_entry(t->name, recent_net->xt_recent);
++		if (recent_net->xt_recent != NULL)
++			remove_proc_entry(t->name, recent_net->xt_recent);
+ #endif
+ 		recent_table_flush(t);
+-		kfree(t);
++		recent_table_free(t);
+ 	}
+ 	mutex_unlock(&recent_mutex);
+ }
+@@ -615,6 +629,20 @@ static int __net_init recent_proc_net_init(struct net *net)
+ 
+ static void __net_exit recent_proc_net_exit(struct net *net)
+ {
++	struct recent_net *recent_net = recent_pernet(net);
++	struct recent_table *t;
++
++	/* recent_net_exit() is called before recent_mt_destroy(). Make sure
++	 * that the parent xt_recent proc entry is is empty before trying to
++	 * remove it.
++	 */
++	spin_lock_bh(&recent_lock);
++	list_for_each_entry(t, &recent_net->tables, list)
++	        remove_proc_entry(t->name, recent_net->xt_recent);
++
++	recent_net->xt_recent = NULL;
++	spin_unlock_bh(&recent_lock);
++
+ 	proc_net_remove(net, "xt_recent");
+ }
+ #else
+@@ -638,9 +666,6 @@ static int __net_init recent_net_init(struct net *net)
+ 
+ static void __net_exit recent_net_exit(struct net *net)
+ {
+-	struct recent_net *recent_net = recent_pernet(net);
+-
+-	BUG_ON(!list_empty(&recent_net->tables));
+ 	recent_proc_net_exit(net);
+ }
+ 
 diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c
 index 9d75b77..e9ea2f3 100644
 --- a/net/sched/sch_htb.c
@@ -17443,7 +20535,7 @@
  	free_irq(IRQ_AC97, NULL);
  	if (ac97conf_clk) {
 diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
-index f9d870e..f419f0a9 100644
+index f9d870e..078fb30 100644
 --- a/sound/pci/hda/hda_intel.c
 +++ b/sound/pci/hda/hda_intel.c
 @@ -559,9 +559,12 @@ enum {
@@ -17461,7 +20553,107 @@
  
  /* quirks for ATI SB / AMD Hudson */
  #define AZX_DCAPS_PRESET_ATI_SB \
-@@ -2557,10 +2560,6 @@ static int azx_runtime_suspend(struct device *dev)
+@@ -647,29 +650,43 @@ static char *driver_short_names[] DELAYED_INITDATA_MARK = {
+ #define get_azx_dev(substream) (substream->runtime->private_data)
+ 
+ #ifdef CONFIG_X86
+-static void __mark_pages_wc(struct azx *chip, void *addr, size_t size, bool on)
++static void __mark_pages_wc(struct azx *chip, struct snd_dma_buffer *dmab, bool on)
+ {
++	int pages;
++
+ 	if (azx_snoop(chip))
+ 		return;
+-	if (addr && size) {
+-		int pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
++	if (!dmab || !dmab->area || !dmab->bytes)
++		return;
++
++#ifdef CONFIG_SND_DMA_SGBUF
++	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_SG) {
++		struct snd_sg_buf *sgbuf = dmab->private_data;
+ 		if (on)
+-			set_memory_wc((unsigned long)addr, pages);
++			set_pages_array_wc(sgbuf->page_table, sgbuf->pages);
+ 		else
+-			set_memory_wb((unsigned long)addr, pages);
++			set_pages_array_wb(sgbuf->page_table, sgbuf->pages);
++		return;
+ 	}
++#endif
++
++	pages = (dmab->bytes + PAGE_SIZE - 1) >> PAGE_SHIFT;
++	if (on)
++		set_memory_wc((unsigned long)dmab->area, pages);
++	else
++		set_memory_wb((unsigned long)dmab->area, pages);
+ }
+ 
+ static inline void mark_pages_wc(struct azx *chip, struct snd_dma_buffer *buf,
+ 				 bool on)
+ {
+-	__mark_pages_wc(chip, buf->area, buf->bytes, on);
++	__mark_pages_wc(chip, buf, on);
+ }
+ static inline void mark_runtime_wc(struct azx *chip, struct azx_dev *azx_dev,
+-				   struct snd_pcm_runtime *runtime, bool on)
++				   struct snd_pcm_substream *substream, bool on)
+ {
+ 	if (azx_dev->wc_marked != on) {
+-		__mark_pages_wc(chip, runtime->dma_area, runtime->dma_bytes, on);
++		__mark_pages_wc(chip, snd_pcm_get_dma_buf(substream), on);
+ 		azx_dev->wc_marked = on;
+ 	}
+ }
+@@ -680,7 +697,7 @@ static inline void mark_pages_wc(struct azx *chip, struct snd_dma_buffer *buf,
+ {
+ }
+ static inline void mark_runtime_wc(struct azx *chip, struct azx_dev *azx_dev,
+-				   struct snd_pcm_runtime *runtime, bool on)
++				   struct snd_pcm_substream *substream, bool on)
+ {
+ }
+ #endif
+@@ -1857,11 +1874,10 @@ static int azx_pcm_hw_params(struct snd_pcm_substream *substream,
+ {
+ 	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
+ 	struct azx *chip = apcm->chip;
+-	struct snd_pcm_runtime *runtime = substream->runtime;
+ 	struct azx_dev *azx_dev = get_azx_dev(substream);
+ 	int ret;
+ 
+-	mark_runtime_wc(chip, azx_dev, runtime, false);
++	mark_runtime_wc(chip, azx_dev, substream, false);
+ 	azx_dev->bufsize = 0;
+ 	azx_dev->period_bytes = 0;
+ 	azx_dev->format_val = 0;
+@@ -1869,7 +1885,7 @@ static int azx_pcm_hw_params(struct snd_pcm_substream *substream,
+ 					params_buffer_bytes(hw_params));
+ 	if (ret < 0)
+ 		return ret;
+-	mark_runtime_wc(chip, azx_dev, runtime, true);
++	mark_runtime_wc(chip, azx_dev, substream, true);
+ 	return ret;
+ }
+ 
+@@ -1878,7 +1894,6 @@ static int azx_pcm_hw_free(struct snd_pcm_substream *substream)
+ 	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
+ 	struct azx_dev *azx_dev = get_azx_dev(substream);
+ 	struct azx *chip = apcm->chip;
+-	struct snd_pcm_runtime *runtime = substream->runtime;
+ 	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
+ 
+ 	/* reset BDL address */
+@@ -1891,7 +1906,7 @@ static int azx_pcm_hw_free(struct snd_pcm_substream *substream)
+ 
+ 	snd_hda_codec_cleanup(apcm->codec, hinfo, substream);
+ 
+-	mark_runtime_wc(chip, azx_dev, runtime, false);
++	mark_runtime_wc(chip, azx_dev, substream, false);
+ 	return snd_pcm_lib_free_pages(substream);
+ }
+ 
+@@ -2557,10 +2572,6 @@ static int azx_runtime_suspend(struct device *dev)
  	struct snd_card *card = dev_get_drvdata(dev);
  	struct azx *chip = card->private_data;
  
@@ -17472,7 +20664,7 @@
  	azx_stop_chip(chip);
  	azx_clear_irq_pending(chip);
  	return 0;
-@@ -2575,12 +2574,25 @@ static int azx_runtime_resume(struct device *dev)
+@@ -2575,12 +2586,25 @@ static int azx_runtime_resume(struct device *dev)
  	azx_init_chip(chip, 1);
  	return 0;
  }
@@ -17499,7 +20691,7 @@
  };
  
  #define AZX_PM_OPS	&azx_pm
-@@ -3439,13 +3451,13 @@ static void __devexit azx_remove(struct pci_dev *pci)
+@@ -3439,13 +3463,13 @@ static void __devexit azx_remove(struct pci_dev *pci)
  static DEFINE_PCI_DEVICE_TABLE(azx_ids) = {
  	/* CPT */
  	{ PCI_DEVICE(0x8086, 0x1c20),
@@ -17655,10 +20847,26 @@
  	case SNDRV_PCM_STATE_OPEN:
  	case SNDRV_PCM_STATE_SETUP:
 diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
-index ad68d22..bbaf67c 100644
+index ad68d22..c98cb89 100644
 --- a/sound/pci/hda/patch_realtek.c
 +++ b/sound/pci/hda/patch_realtek.c
-@@ -5986,6 +5986,30 @@ static void alc269_fixup_quanta_mute(struct hda_codec *codec,
+@@ -4688,6 +4688,7 @@ static const struct snd_pci_quirk alc880_fixup_tbl[] = {
+ 	SND_PCI_QUIRK(0x1584, 0x9077, "Uniwill P53", ALC880_FIXUP_VOL_KNOB),
+ 	SND_PCI_QUIRK(0x161f, 0x203d, "W810", ALC880_FIXUP_W810),
+ 	SND_PCI_QUIRK(0x161f, 0x205d, "Medion Rim 2150", ALC880_FIXUP_MEDION_RIM),
++	SND_PCI_QUIRK(0x1631, 0xe011, "PB 13201056", ALC880_FIXUP_6ST),
+ 	SND_PCI_QUIRK(0x1734, 0x107c, "FSC F1734", ALC880_FIXUP_F1734),
+ 	SND_PCI_QUIRK(0x1734, 0x1094, "FSC Amilo M1451G", ALC880_FIXUP_FUJITSU),
+ 	SND_PCI_QUIRK(0x1734, 0x10ac, "FSC AMILO Xi 1526", ALC880_FIXUP_F1734),
+@@ -5702,6 +5703,7 @@ static const struct alc_model_fixup alc268_fixup_models[] = {
+ };
+ 
+ static const struct snd_pci_quirk alc268_fixup_tbl[] = {
++	SND_PCI_QUIRK(0x1025, 0x015b, "Acer AOA 150 (ZG5)", ALC268_FIXUP_INV_DMIC),
+ 	/* below is codec SSID since multiple Toshiba laptops have the
+ 	 * same PCI SSID 1179:ff00
+ 	 */
+@@ -5986,6 +5988,30 @@ static void alc269_fixup_quanta_mute(struct hda_codec *codec,
  	spec->automute_hook = alc269_quanta_automute;
  }
  
@@ -17689,7 +20897,7 @@
  /* update mute-LED according to the speaker mute state via mic2 VREF pin */
  static void alc269_fixup_mic2_mute_hook(void *private_data, int enabled)
  {
-@@ -6027,6 +6051,7 @@ enum {
+@@ -6027,6 +6053,7 @@ enum {
  	ALC269_FIXUP_DMIC,
  	ALC269VB_FIXUP_AMIC,
  	ALC269VB_FIXUP_DMIC,
@@ -17697,7 +20905,7 @@
  	ALC269_FIXUP_MIC2_MUTE_LED,
  	ALC269_FIXUP_INV_DMIC,
  	ALC269_FIXUP_LENOVO_DOCK,
-@@ -6153,6 +6178,10 @@ static const struct alc_fixup alc269_fixups[] = {
+@@ -6153,6 +6180,10 @@ static const struct alc_fixup alc269_fixups[] = {
  			{ }
  		},
  	},
@@ -17708,7 +20916,7 @@
  	[ALC269_FIXUP_MIC2_MUTE_LED] = {
  		.type = ALC_FIXUP_FUNC,
  		.v.func = alc269_fixup_mic2_mute,
-@@ -6181,6 +6210,8 @@ static const struct snd_pci_quirk alc269_fixup_tbl[] = {
+@@ -6181,6 +6212,8 @@ static const struct snd_pci_quirk alc269_fixup_tbl[] = {
  	SND_PCI_QUIRK(0x1025, 0x029b, "Acer 1810TZ", ALC269_FIXUP_INV_DMIC),
  	SND_PCI_QUIRK(0x1025, 0x0349, "Acer AOD260", ALC269_FIXUP_INV_DMIC),
  	SND_PCI_QUIRK(0x103c, 0x1586, "HP", ALC269_FIXUP_MIC2_MUTE_LED),
@@ -17717,7 +20925,7 @@
  	SND_PCI_QUIRK(0x1043, 0x1427, "Asus Zenbook UX31E", ALC269VB_FIXUP_DMIC),
  	SND_PCI_QUIRK(0x1043, 0x1517, "Asus Zenbook UX31A", ALC269VB_FIXUP_DMIC),
  	SND_PCI_QUIRK(0x1043, 0x1a13, "Asus G73Jw", ALC269_FIXUP_ASUS_G73JW),
-@@ -6535,8 +6566,8 @@ static void alc861vd_fixup_dallas(struct hda_codec *codec,
+@@ -6535,8 +6568,8 @@ static void alc861vd_fixup_dallas(struct hda_codec *codec,
  				  const struct alc_fixup *fix, int action)
  {
  	if (action == ALC_FIXUP_ACT_PRE_PROBE) {
@@ -17742,7 +20950,7 @@
  			  "HP", STAC_92HD83XXX_HP_cNB11_INTQUAD),
  	SND_PCI_QUIRK(PCI_VENDOR_ID_HP, 0x165B,
 diff --git a/sound/soc/codecs/arizona.c b/sound/soc/codecs/arizona.c
-index 054967d..08ae3cb 100644
+index 054967d..f9d9f68 100644
 --- a/sound/soc/codecs/arizona.c
 +++ b/sound/soc/codecs/arizona.c
 @@ -409,15 +409,9 @@ static int arizona_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
@@ -17761,6 +20969,15 @@
  	default:
  		arizona_aif_err(dai, "Unsupported DAI format %d\n",
  				fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+@@ -654,7 +648,7 @@ static int arizona_hw_params(struct snd_pcm_substream *substream,
+ 	}
+ 	sr_val = i;
+ 
+-	lrclk = snd_soc_params_to_bclk(params) / params_rate(params);
++	lrclk = rates[bclk] / params_rate(params);
+ 
+ 	arizona_aif_dbg(dai, "BCLK %dHz LRCLK %dHz\n",
+ 			rates[bclk], rates[bclk] / lrclk);
 @@ -677,7 +671,8 @@ static int arizona_hw_params(struct snd_pcm_substream *substream,
  		snd_soc_update_bits(codec, ARIZONA_ASYNC_SAMPLE_RATE_1,
  				    ARIZONA_ASYNC_SAMPLE_RATE_MASK, sr_val);
@@ -17857,10 +21074,27 @@
  
  	wm2000_write(i2c, WM2000_REG_SYS_START0, 0x33);
 diff --git a/sound/soc/codecs/wm2200.c b/sound/soc/codecs/wm2200.c
-index eab64a1..7ef4e96 100644
+index eab64a1..0f2bb25 100644
 --- a/sound/soc/codecs/wm2200.c
 +++ b/sound/soc/codecs/wm2200.c
-@@ -1380,15 +1380,9 @@ static int wm2200_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+@@ -897,8 +897,6 @@ static const char *wm2200_mixer_texts[] = {
+ 	"EQR",
+ 	"LHPF1",
+ 	"LHPF2",
+-	"LHPF3",
+-	"LHPF4",
+ 	"DSP1.1",
+ 	"DSP1.2",
+ 	"DSP1.3",
+@@ -931,7 +929,6 @@ static int wm2200_mixer_values[] = {
+ 	0x25,
+ 	0x50,   /* EQ */
+ 	0x51,
+-	0x52,
+ 	0x60,   /* LHPF1 */
+ 	0x61,   /* LHPF2 */
+ 	0x68,   /* DSP1 */
+@@ -1380,15 +1377,9 @@ static int wm2200_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
  	case SND_SOC_DAIFMT_DSP_A:
  		fmt_val = 0;
  		break;
@@ -17876,7 +21110,7 @@
  	default:
  		dev_err(codec->dev, "Unsupported DAI format %d\n",
  			fmt & SND_SOC_DAIFMT_FORMAT_MASK);
-@@ -1440,7 +1434,7 @@ static int wm2200_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+@@ -1440,7 +1431,7 @@ static int wm2200_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
  			    WM2200_AIF1TX_LRCLK_MSTR | WM2200_AIF1TX_LRCLK_INV,
  			    lrclk);
  	snd_soc_update_bits(codec, WM2200_AUDIO_IF_1_5,
@@ -18158,6 +21392,39 @@
  	return 0;
  }
  
+diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
+index 298070e..41e8bfb 100644
+--- a/sound/usb/mixer.c
++++ b/sound/usb/mixer.c
+@@ -1259,16 +1259,23 @@ static int parse_audio_feature_unit(struct mixer_build *state, int unitid, void
+ 		}
+ 		channels = (hdr->bLength - 7) / csize - 1;
+ 		bmaControls = hdr->bmaControls;
++		if (hdr->bLength < 7 + csize) {
++			snd_printk(KERN_ERR "usbaudio: unit %u: "
++				   "invalid UAC_FEATURE_UNIT descriptor\n",
++				   unitid);
++			return -EINVAL;
++		}
+ 	} else {
+ 		struct uac2_feature_unit_descriptor *ftr = _ftr;
+ 		csize = 4;
+ 		channels = (hdr->bLength - 6) / 4 - 1;
+ 		bmaControls = ftr->bmaControls;
+-	}
+-
+-	if (hdr->bLength < 7 || !csize || hdr->bLength < 7 + csize) {
+-		snd_printk(KERN_ERR "usbaudio: unit %u: invalid UAC_FEATURE_UNIT descriptor\n", unitid);
+-		return -EINVAL;
++		if (hdr->bLength < 6 + csize) {
++			snd_printk(KERN_ERR "usbaudio: unit %u: "
++				   "invalid UAC_FEATURE_UNIT descriptor\n",
++				   unitid);
++			return -EINVAL;
++		}
+ 	}
+ 
+ 	/* parse the source unit */
 diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
 index 0f58b4b..b8d1ad1 100644
 --- a/sound/usb/quirks.c
@@ -18285,6 +21552,19 @@
  out_delete_evlist:
  	perf_evlist__delete(evlist);
  out:
+diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c
+index 9718e98..62e7bd6 100644
+--- a/virt/kvm/eventfd.c
++++ b/virt/kvm/eventfd.c
+@@ -332,7 +332,7 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
+ 		mutex_lock(&kvm->irqfds.resampler_lock);
+ 
+ 		list_for_each_entry(resampler,
+-				    &kvm->irqfds.resampler_list, list) {
++				    &kvm->irqfds.resampler_list, link) {
+ 			if (resampler->notifier.gsi == irqfd->gsi) {
+ 				irqfd->resampler = resampler;
+ 				break;
 diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
 index be70035..6e8fa7e 100644
 --- a/virt/kvm/kvm_main.c
